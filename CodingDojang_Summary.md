# UNIT 1~4

<br>

문자열 출력
-----------

`print` 함수는 화면(표준 출력)에 값을 출력하는 함수이다.

```python
print('Hello, world!')  # Hello, world!
```

<br>

파이썬 스크립트 실행
--------------------

파이썬 코드를 저장한 `.py` 파일을 파이썬 스크립트 또는 스크립트 파일이라고 부르며 콘솔(터미널, 명령 프롬프트)에서 `python 스크립트파일.py` 형식으로 실행할 수 있다(리눅스와 macOS에서는 `python3 스크립트파일.py` 형식)

<br>

주석
----

주석은 소스 코드에 대한 설명을 작성하거나 코드를 임시로 사용하지 않도록 만들 때 사용한다.

```python
# Hello, world! 출력
print('Hello, world!')

# 코드를 사용하지 않음
#print('Hello, world!')

# 여러 줄로 된
# 블록 주석
# print('Hello, world!')
```

<br>

컴퓨테이셔널 씽킹과 알고리즘의 차이점은 무엇인가?
-------------------------------------------------

컴퓨테이셔널 씽킹은 4가지로 되어 있다.

1. **분해**: 복잡한 문제를 작은 문제로 나눈다.
2. **패턴 인식**: 문제 안에서 유사성을 발견한다.
3. **추상화**: 문제의 핵심에만 집중하고 부차적인 것은 제외한다.
4. **알고리즘**: 이렇게 정의한 문제를 해결하는 절차이다.

복잡한 문제를 해결하는 것은 어렵지만, 작은 문제를 해결하는 것은 비교적 쉽다. 작은 문제를 해결하다 보면 복잡한 문제를 해결하게 된다. 컴퓨터 공학에서 배우는 알고리즘은 대부분 정형화된 문제에 대해 검증된 해법을 제시하는 과목이다.

현실에서 컴퓨터로 해결하려는 문제는 정형화된 문제가 아니라 비정형화된 문제가 더 많다. 그래서 비정형화된 문제를 컴퓨터로 해결하는 과정, 즉 문제를 이해하고 분해, 패턴 인식, 추상화, 알고리즘 작성까지를 컴퓨테이셔널 씽킹이라고 한다.

<br><br>



# UNIT 5~7

<br>

숫자 계산하기
-------------

숫자의 덧셈은 `+`, 뺄셈은 `-`, 곱셈은 `*`, 나눗셈은 `/` 연산자를 사용한다. 특히 파이썬 셸은 숫자의 계산 결과를 바로 출력할 수 있다.

```python
>>> 1 + 1
2
>>> 1 - 2
-1
>>> 2 * 2
4
>>> 5 / 2
2.5
```

<br>

계산 결과를 정수, 실수로 만들기
-------------------------------

`int`에 `()` 괄호를 붙이고 값 또는 계산식을 넣으면 결과를 정수로 만들며, `float`에 넣으면 실수로 만든다.

```python
>>> int(5/2)        # 실수 2.5를 정수 2로 만듦
2
>>> float(1 + 2)    # 정수 3을 실수 3.0으로 만듦
3.0
```

<br>

괄호 사용하기
-------------

식에서 덧셈, 뺄셈, 곱셈, 나눗셈이 함께 있을 때는 곱셈과 나눗셈부터 계산한다. 만약 곱셈보다 덧셈을 먼저 계산하고 싶다면 덧셈 부분을 `()`(괄호)로 묶어준다.

```python
>>> 35 + 1 * 2
37
>>> (35 + 1) * 2
72
```

<br>

변수 만들기
-----------

변수는 `변수이름 = 값` 형식으로 만든다.

```python
x = 10
```

<br>

변수 삭제하기
-------------

변수를 삭제할 때는 `del 변수` 형식으로 삭제한다.
```python
>>> x = 10
>>> del x
```

<br>

변수 여러 개 만들기
-------------------

변수 여러 개를 한 번에 만들 때는 `변수이름1, 변수이름2, 변수이름3 = 값1, 값2, 값3`과 같이 변수를 `,`(콤마)로 구분한 뒤 각 변수에 할당될 값을 지정해 주면 된다.

```python
a, b, c = 10, 20, 30
```

또는, `변수1 = 변수2 = 변수3 = 값`과 같이 변수 여러 개를 `=`로 연결하고 마지막에 값을 할당해두면 같은 값을 가진 변수 여러 개가 만들어진다.

```python
x = y = z = 10
```

<br>

산술 연산 후 할당 연산자 사용하기
---------------------------------

산술 연산자 앞에 `=`(할당 연산자)를 붙이면 연산 결과를 변수에 저장한다. 단, 이때는 미리 변수를 만들고 값을 할당해 두어야 한다.

```python
>>> a = 10
>>> a += 20
>>> a
30
```

`a += 20`는 `a = a + 20`을 축약한 형태이다.

<br>

객체의 자료형 알아내기
----------------------

객체(변수)가 어떤 타입(자료형)인지 알고 싶을 때는 `type` 함수를 사용한다.

```python
>>> type(3.3)
<class 'float'>
>>> x = 10
>>> type(x)
<class 'int'>
```

파이썬에서는 숫자도 객체(object)이며, 객체는 클래스(class)로 표현한다.

<br>

입력 값을 변수에 저장하기
-------------------------

입력 값을 변수에 저장할 때는 `input` 함수를 사용합니다. 여기서 `input`을 그대로 사용하면 문자열로 저장되고 `inpu`을 `int`에 넣어주면 정수, `float`에 넣어주면 실수로 저장한다.

```python
s = input()         # 입력값을 문자열로 저장
a = int(input())    # 입력값을 정수로 저장
b = float(input())  # 입력값을 실수로 저장
```

<br>

한 번에 여러 개 입력받기
------------------------

`input` 함수로 값을 여러 개 입력받으려면 `input`에서 `split`응ㄹ 사용하면 됩니다. 만약 `split`의 결과를 정수 또는 실수로 반환하려면 `map`에 `int` 또는 `float`를 지정해준다.

```python
a, b = input().split()              # 값 두 개를 입력받아 변수 두 개에 문자열로 저장
a, b = map(int, input().split())    # 값 두 개를 입력받아 변수 두 개에 정수로 저장
a, b = map(float, input().split())  # 값 두 개를 입력받아 변수 두 개에 실수로 저장
```

<br>

값을 여러 개 출력하기
---------------------

`print` 함수로 값을 여러 개 출력하려면 변수나 값을 `,`(콤마)로 구분해서 넣어준다.

```python
>>> print(1, 2, 3)
1 2 3
```

<br>

`print` 함수의 출력 방식 제어하기
---------------------------------

`print` 함수의 `sep`에 문자(문자열)를 지정하면 값 사이에 문자(문자열)를 넣어준다.

```python
>>> print(1, 2, 3, sep=', ')    # 값 사이에 ,와 공백 출력
1, 2, 3
```

`print` 함수의 `end`에 문자(문자열)를 지정하면 출력하는 값 끝에 해당 문자(문자열)를 넣어준다.

```python
print(1, end='')    # 1을 출력한 뒤 공백 출력
print(2)            # 2가 이어서 출력됨
```
```shell
1 2
```

<br>

개행 문자(줄바꿈 문자)
----------------------

문자열에서 제어 문자 `\n`을 사용하면 다음 줄로 넘어간다.

```python
>>> print('1\n2\n3')    # \n을 사용하면 다음 줄로 넘어감
1
2
3
```

<br>

산술 연산자
-----------

| 연산자 | 기능                         | 문법      | 설명                                                        |
| ------ | ---------------------------- | --------- | ----------------------------------------------------------- |
| `+`    | 덧셈                         | `a + b`   | 두 값을 더함                                                |
| `-`    | 뺄셈                         | `a - b`   | `a`에서 `b`를 뺌                                            |
| `*`    | 곱셈                         | `a * b`   | 두 값을 곱함                                                |
| `/`    | 나눗셈                       | `a / b`   | `a`에서 `b`를 나누며 결과는 실수                            |
| `//`   | 버림 나눗셈 (floor division) | `a // b`  | `a`에서 `b`를 나누며 소수점 이하는 버림                     |
| `%`    | 나머지                       | `a % b`   | `a`에서 `b`를 나누었을 때 나머지를 구함                     |
| `**`   | 거듭제곱                     | `a ** b`  | `a`를 `b`번 곱함                                            |
| `@`    | 행렬 곱셈                    | `a @ b`   | 행렬 `a`와 `b`를 곱함                                       |
| `+`    | 양수 부호                    | `+a`      | `a`에 양수 부호를 붙임                                      |
| `-`    | 음수 부호                    | `-a`      | `a`에 음수 부호를 붙임                                      |
| `+=`   | 덧셈 후 할당                 | `a += b`  | `a`와 `b`를 더한 후 결과를 `a`에 할당                       |
| `-=`   | 뺄셈 후 할당                 | `a -= b`  | `a`에서 `b`를 뺀 후 결과를 `a`에 할당                       |
| `*=`   | 곱셈 후 할당                 | `a *= b`  | `a`와 `b`를 곱한 후 결과를 `a`에 할당                       |
| `/=`   | 나눗셈 후 할당               | `a /= b`  | `a`에서 `b`를 나눈 후 결과를 `a`에 할당(결과는 실수)        |
| `//=`  | 버림 나눗셈 후 할당          | `a //= b` | `a`에서 `b`를 나눈 후 결과를 `a`에 할당(소수점 이하는 버림) |
| `%=`   | 나머지 연산 후 할당          | `a %= b`  | `a`에서 `b`를 나누었을 때 나머지를 구하여 `a`에 할당        |
| `**=`  | 거듭제곱 후 할당             | `a **= b` | `a`를 `b`번 곱한 후 결과를 `a`에 할당                       |
| `@=`   | 행렬 곱셈 후 할당            | `a @= b`  | 행렬 `a`와 `b`를 곱한 후 결과를 `a`에 할당                  |

<br>

변수에 값이 어떻게 저장되나?
----------------------------

파이썬은 값 자체도 객체이다. 그래서 변수에 값을 그대로 저장하지 않고 객체를 가리키는 방식을 사용한다. 예를 들어서 다음과 같이 `x`와 `y`에 1000을 할당했다면 `x`와 `y`는 단지 1000이라는 객체를 가리킬 뿐이다.

```python
x = 1000
y = 1000
```

정말 그런지 확인해보자. `sys.getrefcount` 함수를 사용하면 현재 객체가 몇 번 사용되었는지 확인할 수 있다(객체를 사용(참조)한 횟수를 레퍼런스 카운트(reference count)라고 부른다).

```python
# refcount.py
import sys
print(sys.getrefcount(1000))        # 2: Windows에서 처음 레퍼런스 카운트는 2
                                    # 3: Linux에서 처음 레퍼런스 카운트는 3
x = 1000                            # x에 1000을 저장
print(sys.getrefcount(1000))        # 3: 1000을 한 번 사용하여 레퍼런스 카운트 1 증가 (Windows)
y = 1000                            # y에 1000을 저장
print(sys.getrefcount(1000))        # 4: 1000을 한 번 사용하여 레퍼런스 카운트 1 증가 (Windows)
                                    # 5: 리눅스
print(x is y)                       # True: x와 y가 같은 객체를 가리키고 있으므로 True로 나옴
```

변수를 만들어 1000을 사용할 때마다 `sys.getrefcount`의 결과가 1씩 증가한다. 여기서 맨 처음에 `sys.getrefcount(1000)`를 실행했을 때 0이 아닌 2가 나오는 이유는 `sys.getrefcount`를 호출하면서 내부적으로 1000을 두 번 사용했기 때문이다. 1, 2처럼 흔한 숫자를 넣어보면 훨씬 많은 값이 나온다. 왜냐하면 파이썬 내부에서도 1, 2를 사용하고 있기 때문이다.

그리고 객체가 같은지 판단하는 연산자인 `is`를 사용해보면 `True`가 나온다. 즉 `x`와 `y`는 같은 객체를 가리키고 있다.

Windows와 리눅스의 결과가 다른 이유는 내부 구현이 조금 다르기 때문이다. 이 부분은 실제 사용에 영향을 주지 않으므로 신경 쓰지 않아도 된다.

<br>

줄바꿈 방식은 `\n` 말고도 `\r`, `\r\n`이 있던데 차이점이 무엇인가?
------------------------------------------------------------------

`\r`은 캐리지 리턴(Carriage Return, CR), `\n`은 라인 피드(Line Feed, LF)이라고 부른다. 사실 이 둘은 타자기에서 나온 용어이다. 타자기에서 줄바꿈을 하려면 종이를 오른쪽으로 쭉 밀고, 다시 종이를 한 줄 만큼 위로 올린다. 이렇게 종이를 오른쪽으로 밀어서 처음으로 오게 하는 행동을 복귀(Carriage Return)라고 하고, 종이를 위로 올리는 행동을 개행(Line Feed)이라고 한다. 이제 타자기는 사라지고 컴퓨터와 키보드로 대체되었지만 타자기의 흔적이 완전히 사라지지 않고 남은 것이 CR(`\r`)과 LF(`\n`)이다. 컴퓨터에서 CR, LF는 둘 다 새 줄, 줄바꿈으로 사용되고 있으며 운영체제별로 조금씩 차이가 있다. 다음은 텍스트 파일을 저장할 때 줄바꿈 규칙이다.

* Windows: CR LF(`\r\n`)
* 유닉스, 리눅스, macOS: LF(`\n`)
* Mac OS 9(클래식): CR(`\r`)

파이썬에서는 줄바꿈을 할 때 운영체제에 상관없이 `\n`만 사용하면 된다.

<br>

행렬 곱셈 연산자는 어떻게 사용하나?
-----------------------------------

행렬 곱셈 연산자는 파이썬 3.5 이상부터 사용할 수 있으며 `numpy` 모듈을 설치해야 한다(`pip install numpy`).

```python
import numpy as np                                  # numpy 모듈을 가져옴
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])     # 3x3 행렬  생성
b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])     # 3x3 행렬 생성
a @ b                                               # 행렬 곱셈
                                                    # array([[ 30,  36,  42],
                                                    #        [ 66,  81,  96],
                                                    #        [102, 126, 150]])
```

<br>

파이썬 셸에서 직전에 실행된 결과를 다시 가져올 수 있나?
-------------------------------------------------------

파이썬 셸에서 코드를 실행했을 때 결과는 `_`(밑줄 문자) 변수에 저장된다. 따라서 `_`를 사용하면 직전에 실행된 결과를 다시 가져올 수 있다.

```python
>>> 1 + 1
2
>>> _
2
```

<br><br>



# UNIT 8~12

불
--

불은 `True`, `False`로 표현한다. 특히 비교 연산자, 논리 연산자의 판단 결과로 `True`, `False`를 사용한다.

<br>

비교 연산자
-----------

| 연산자   | 문법         | 설명                       |
| -------- | ------------ | -------------------------- |
| `==`     | `a == b`     | 같음                       |
| `!=`     | `a != b`     | 같지 않음, 다름            |
| `>`      | `a > b`      | 큼, 초과                   |
| `<`      | `a < b`      | 작음, 미만                 |
| `>=`     | `a >= b`     | 크거나 같음, 이상          |
| `<=`     | `a <= b`     | 작거나 같음, 이하          |
| `is`     | `a is b`     | 같음(객체 비교)            |
| `is not` | `a is not b` | 같지 않음, 다름(객체 비교) |

<br>

논리 연산자
-----------

| 연산자 | 문법      | 설명                                   |
| ------ | --------- | -------------------------------------- |
| `and`  | `a and b` | AND(논리곱), 양쪽 모두 참일 때 참      |
| `or`   | `a or b`  | OR(논리합), 양쪽 중 한쪽만 참이라도 참 |
| `not`  | `not x`   | NOT(논리 부정), 참과 거짓을 뒤집음     |

<br>

문자열
------

문자열은 `''`(작은따옴표) 또는 `""`(큰따옴표)로 묶어서 표현한다.

```python
'Hello, world!'
"Hello, world!"
```

<br>

여러 줄로 된 문자열
-------------------

여러 줄로 된 문자열은 `'''`(작은따옴표 3개)로 시작해서 `'''`로 닫거나 `"""`(큰따옴표 3개)로 시작해서 `"""`로 닫아서 표현한다.

```python
'''Hello, world!
안녕하세요
Python입니다.'''

"""Hello, world!
안녕하세요
Python입니다."""
```

<br>

리스트
------

리스트는 여러 개의 값(요소)을 일렬로 늘어놓은 형태이다. 변수에 값을 저장할 때 `[]`(대괄호)로 묶어주면 리스트가 되며 각 값은 `,`(콤마)로 구분한다. 리스트에 저장된 요소에 접근할 때는 `[]` 안에 인덱스를 지정해준다. 특히 리스트의 인덱스는 `0`부터 시작한다.

```python
리스트 = [값, 값, 값]       # 리스트 만들기
리스트 = []                 # 빈 리스트 만들기
리스트 = list()             # 빈 리스트 만들기
리스트 = list(range(횟수))  # range로 리스트 만들기

리스트[인덱스]              # 리스트의 요소에 접근
리스트[0]                   # 리스트의 인덱스는 0부터 시작하므로 첫 번째 요소
리스트[인덱스] = 값         # 리스트의 요소에 값 저장
```

<br>

range
-----

range는 연속된 숫자를 생성한다. 이때 지정한 횟수는 생성되는 숫자에 포함되지 않는다. 그리고 시작하는 숫자와 끝나는 숫자를 지정했을 때 끝나는 숫자는 생성되는 숫자에 포함되지 않는다.

```python
range(횟수)
range(시작, 끝)
range(시작, 끝, 증가폭)
```

<br>

튜플
----

튜플은 여러 개의 값(요소)을 일렬로 늘어놓은 형태이다. 단, 요소의 값을 변경하거나 추가할 수 없다(읽기 전용). 변수에 값을 저장할 때 `()`(괄호)로 묶어주면 튜플이 되며 각 값은 콤마로 구분한다. 또는, 괄호로 묶지 않고 값만 콤마로 구분해도 튜플이 된다. 튜플에 저장된 요소에 접근할 때는 `[]`안에 인덱스를 지정해준다. 그리고 리스트와 마찬가지로 튜플의 인덱스도 `0`부터 시작한다.

```python
튜플 = (값, 값, 값)         # 튜플 만들기
튜플 = 값, 값, 값           # 괄호 없이 튜플 만들기
튜플 = ()                   # 빈 튜플 만들기
튜플 = tuple()              # 빈 튜플 만들기
튜플 = tuple(list())        # tuple에 list()를 넣어서 튜플 만들기
튜플 = tuple(리스트)        # tuple에 리스트를 넣어서 튜플 만들기
튜플 = tuple(range(횟수))   # range로 튜플 만들기

튜플[인덱스]                # 튜플의 요소에 접근
튜플[0]                     # 튜플의 인덱스는 0부터 시작하므로 첫 번째 요소

튜플 = (값, )               # 요소가 한 개인 튜플 만들기
튜플 = 값,                  # 요소가 한 개인 튜플 만들기
```

<br>

시퀀스 자료형
-------------

파이썬에서 리스트(list), 튜플(tuple), range, 문자열(str)과 같이 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence type)이라고 한다. 그리고 시퀀스 자료형으로 만든 객체를 스퀀스 객체라고 하며, 시퀀스 객체에 들어있는 각 값을 요소(element)라고 부른다.

<br>

시퀀스 자료형의 공통 기능
-------------------------

파이썬의 시퀀스 자료형은 공통된 동작과 기능을 제공한다. 따라서 리스트, 튜플, range, 문자열 등의 시퀀스 자료형은 같은 문법을 사용한다.

```python
값 in 시퀀스객체            # 시퀀스 객체에 특정 값이 있는지 확인
값 not in 시퀀스객체        # 시퀀스 객체에 특정 값이 없는지 확인

시퀀스객체1 + 시퀀스객체2   # 시퀀스 객체를 서로 연결하여 새 시퀀스 객체를 만듦
시퀀스객체 * 정수           # 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만듦
정수 * 시퀀스객체           # 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만듦

len(시퀀스객체)             # 시퀀스 객체읭 요소 개수(길이) 구하기

시퀀스객체[인덱스]          # 시퀀스 객체의 요소에 접근
시퀀스객체[0]               # 시퀀스 객체의 인덱스는 0부터 시작하므로 첫 번째 요소
시퀀스객체[-음수]           # 인덱스를 음수로 지정하면 뒤에서부터 요소에 접근; -1은 뒤에서 첫 번째
시퀀스객체[인덱스] = 값     # 시퀀스 객체의 요소에 값 저장

del 시퀀스객체[인덱스]      # 시퀀스 객체의 요소를 삭제
```

<br>

시퀀스 자료형의 슬라이스
------------------------

시퀀스 자료형은 시퀀스 객체의 일부를 잘라내서 가져오는 슬라이스(slice)를 사용할 수 있다. `[]`(대괄호) 안에 시작 인덱스와 끝 인덱스를 지정하면 해당 범위의 요소를 잘라서 새 시퀀스 객체를 만든다. 단, 끝 인덱스는 가져오려는 범위에 포함되지 않는다.

```python
시퀀스객체[시작인덱스:끝인덱스]                             # 지정된 범위의 요소를 잘라서 새 시퀀스 객체를 만듦
시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭]                # 인덱스 증가폭을 지정하면 해당 값만큼
                                                            # 인덱스를 증가시키면서 요소를 가져옴

시퀀스객체[:끝인덱스]                                       # 시작 인덱스를 생략하여 객체의 처음부터 끝 인덱스-1까지 가져옴
시퀀스객체[시작인덱스:]                                     # 끝 인덱스를 생략하여 시작 인덱스부터 마지막 요소까지 가져옴
시퀀스객체[:]                                               # 시작 인덱스와 끝 인덱스를 생략하여 객체 전체를 가져옴

시퀀스객체[0:len(시퀀스객체)]                               # len을 응용하여 객체 전체를 가져옴
시퀀스객체[:len(시퀀스객체)]                                # 시작 인덱스 생략, len을 응용하여 객체 전체를 가져옴

시퀀스객체[:끝인덱스:증가폭]                                # 객체의 처음부터 증가폭만큼 인덱스를 증가시키면서
                                                            # 끝 인덱스-1까지 요소를 가져옴
시퀀스객체[시작인덱스::증가폭]                              # 시작 인덱스부터 증가폭만큼 인덱스를 증가시키면서
                                                            # 마지막 요소까지 가져옴
시퀀스객체[::증가폭]                                        # 객체 전체에서 증가폭만큼 인덱스를 증가시키면서 요소를 가져옴

시퀀스객체[::]                                              # 객체 전체를 가져옴, 시퀀스객체[:]와 같음

시퀀스객체[시작인덱스:끝인덱스] = 시퀀스객체                # 범위를 지정하여 여러 요소에 값 할당
시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭] = 시퀀스객체   # 증가폭만큼 인덱스를 건너뛰면서 할당

del 시퀀스객체[시작인덱스:끝인덱스]                         # 특정 범위의 요소를 삭제(원본 객체가 변경됨)
```

<br>

딕셔너리
--------

딕셔너리는 연관된 값을 묶어서 저장하는 자료형이다. `{}`(중괄호) 안에 `키:값` 형식으로 저장하며 각 키와 값은 `,`(콤마)로 구분한다. 딕셔너리에 저장된 값에 접근할 때는 `[]`(대괄호) 안에 키를 지정해준다.

```python
딕셔너리 = {키1:값1, 키2:값2}   # 딕셔너리 만들기
딕셔너리 = {}                   # 빈 딕셔너리 만들기
딕셔너리 = dict()               # 빈 딕셔너리 만들기

딕셔너리[키]                    # 딕셔너리에서 키로 값에 접근
딕셔너리[키] = 값               # 딕셔너리에서 키에 값 할당

키 in 딕셔너리                  # 딕셔너리에 특정 키가 있는지 확인
키 not in 딕셔너리              # 딕셔너리에 특정 키가 없는지 확인

len(딕셔너리)                   # 딕셔너리의 키 개수(길이) 구하기
```

<br>

컨테이너란 무엇인가?
--------------------

컨테이너는 화물을 수송할 때 사용하는 큰 박스를 말하는데, 파이썬에서는 데이터를 담는 자료형인 리스트, 튜플, 딕셔너리, 세트를 컨테이너(container)라 부른다.

<br>

딕셔너리는 키의 순서가 보장되나?
--------------------------------

파이썬 3.5 이하에서는 키의 순서가 정해져 있지 않다. 하지만, 파이썬 3.6부터는 딕셔너리를 생성했을 때와 키를 추가했을 때의 순서를 따르므로 순서가 보장된다.

다음과 같이 파이썬 3.6 이상에서 딕셔너리를 만들어보면 키의 순서가 바뀌지 않고 계속 유지된다.

```python
# 파이썬 3.6
>>> lux = {'health': 490, 'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux
{'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
```

파이썬 3.5와 그 이하 버전에서는 키의 순서가 보장되지 않는다.

```python
# 파이썬 3.5
>>> lux = {'health': 490, 'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux
{'armor': 18.72, 'health': 800, 'mana': 334, 'melee': 550}
```

만약 파이썬 3.5 이하에서 키의 순서가 보장되도록 만들려면 `collections` 모듈의 `OrderedDict`를 사용하면 된다.

* `OrderedDict(딕셔너리)`

```python
>>> from collections import OrderedDict
>>> lux = OrderedDict({'health': 490, 'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72})
>>> lux
OrderedDict([('health', 800), ('mana', 334), ('melee', 550), ('armor', 18.72)])
```

<br><br>



# Unit 13~15

<br>

특정 조건일 때 코드를 실행하기
------------------------------

`if` 조건문에 조건식을 지정하면 해당 조건을 만족할 때 코드를 실행할 수 있다.

```python
if 조건식:
    코드    # 조건식을 만족할 때 코드 실행
```

<br>

두 방향으로 분기하기
--------------------

`if`와 `else`를 사용하면 조건식을 만족할 때와 만족하지 않을 때 각각 다른 코드를 실행할 수 있다.

```python
if 조건식:
    코드1   # 조건식을 만족할 때 코드 실행
else:
    코드2   # 조건식을 만족하지 않을 때 코드 실행
```

<br>

여러 방향으로 분기하기
----------------------

`elif`는 여러 개의 조건식을 지정하여 각각 다른 코드를 실행할 수 있다.

```python
if 조건식1:
    코드1   # 조건식1을 만족할 때 코드 실행
elif 조건식2:
    코드2   # 조건식2를 만족할 때 코드 실행
elif 조건식3
    코드3   # 조건식3을 만족할 때 코드 실행
else:
    코드4   # 어떤 조건도 만족하지 않을 때 코드 실행
```

<br>

`if` 조건문과 들여쓰기
----------------------

`if` 다음에 오는 코드는 반드시 들여쓰기를 해야 하고, 깊이가 같아야 한다.

```python
if x == 10:
    print(x)        # 올바른 코드

if x == 10:
print(x)            # 잘못된 코드
```

```python
if x == 10:
    print(x)        # 올바른 코드
    print(10)       # 올바른 코드

if x == 10:
    print(x)        # 잘못된 코드
        print(10)   # 잘못된 코드
```

<br>

조건식과 `==` 연산자
--------------------

조건식을 작성할 때 `==` 연산자 대신 `=` 연산자를 사용하는 실수를 하지 않도록 주의한다.

```python
if x == 1:      # 올바른 조건식
    print(x)

if x = 1:       # 잘못된 조건식
    print(x)
```

<br>

참과 거짓
---------

파이썬에서 참은 `True`, 거짓은 `False`를 사용하지만 다음 값들도 `True` 또는 `False`로 취급되므로 조건식을 작성할 때 주의해야 한다.

* `True`로 취급: 0이 아닌 숫자, 내용이 있는 문자열, 리스트, 튜플, 딕셔너리, 세트
* `False`로 취급: 0, `None`, 비어있는 문자열, 리스트, 튜플, 딕셔너리, 세트

<br><br>



# UNIT 16~21

<br>

반복할 횟수를 지정하여 반복하기
-------------------------------

`for` 반복문은 반복할 횟수를 지정하여 반복할 수 있다. `range`에 반복할 횟수를 지정하고 앞에 `in`과 변수를 지정한다.

```python
for 변수 in range(횟수):
    반복할 코드
```

<br>

반복할 횟수가 정해져 있지 않을 때 반복하기
------------------------------------------

`while` 반복문은 반복 횟수가 정해져 있지 않을 때, 논리 조건에 따라 반복 여부를 결정할 때 사용한다. 조건식이 만족하면 계속 반복하고, 만족하지 않으면 반복을 끝낸다(예를 들어 데이터를 다 읽을 때까지 반복하는 경우).

```python
초기식
while 조건식:
    반복할 코드
    조건식의 결과에 영향을 주는 코드(변화식)
```

<br>

반복문 끝내기
-------------

반복문에서 `break`를 사용하면 반복문을 끝낼 수 있다.

```python
while 조건식1:
    if 조건식2:
        break   # 반복문을 끝냄
```

<br>

반복문의 코드 건너뛰기
----------------------

반복문에서 `continue`를 사용하면 반복문의 일부 코드를 건너뛸 수 있다. 단, 반복문을 끝내지 않고 계속 반복한다.

```python
while 조건식1:
    if 조건식2:
        continue    # 아래 코드를 건너뛴 뒤 계속 반복함
    코드
```

<br>

중첩 루프
---------

반복문 안에 반복문이 들어 있는 형태를 중첩 루프라고 하며 루프 인덱스 변수는 `i`부터 순서대로 짓는다.

* 예) `i`, `j`, `k`

중첩 루프는 주로 가로X세로 형태로 된 2차원 평면을 다룰 때 사용한다.

```python
for i in range(10):     # 바깥쪽 루프
    for j in range(10): # 안쪽 루프
        pass
```

<br>

반복문과 들여쓰기
-----------------

`for`, `while` 다음에 오는 코드는 반드시 들여쓰기를 해야 하고, 깊이가 같아야 한다.

```python
for i in range(10):
    print(i)    # 올바른 코드

for i in range(10):
print(i)        # 잘못된 코드
```

```python
while i < 10:
    print(i)    # 올바른 코드
    i += 1      # 올바른 코드

while i < 10:
    print(i)    # 잘못된 코드
        i += 1  # 잘못된 코드
```

<br>

FizzBuzz 문제의 의도
--------------------

FizzBuzz 문제는 겉으로 보기에는 `if` 조건문과 나머지 연산자를 사용하는 방법을 묻는 것 같지만 실제로는 요구사항을 정확히 파악하여 구현했는지를 평가하는 문제이다.

가장 많이 실수하는 부분은 3과 5의 공배수인데도 3의 배수로만 처리한다거나 5의 배수로만 처리하고 넘어가는 것이다. 제시된 요구사항을 순서대로 `if`, `elif`, `else`로 만들다 보면 이런 실수를 하게 된다. 따라서 문제의 요구사항을 정확히 파악하여 중요한 내용이 무엇인지 확인하고, 놓친 부분은 없는지 살펴봐야 한다(여기서는 공배수 처리 부분).

<br>

터틀 그래픽스
-------------

`turtle` 모듈은 펜으로 그림을 그리는 모듈이다.

| 메서드                                         | 설명                                                                         |
| ---------------------------------------------- | ---------------------------------------------------------------------------- |
| `shape('모양')`                                | 터틀 모양 지정(`arrow`, `turtle`, `circle`, `square`, `triangle`, `classic`) |
| `shape()`                                      | 현재 모양 확인                                                               |
| `mainloop()`                                   | 터틀 창 유지                                                                 |
| `forward(거리)`<br>`fd(거리)`                  | 앞으로 이동                                                                  |
| `backward(거리)`<br>`bk(거리)`<br>`back(거리)` | 뒤로 이동                                                                    |
| `left(각도)`<br>`lt(각도)`                     | 왼쪽으로 회전                                                                |
| `right(각도)`<br>`rt(각도)`                    | 오른쪽으로 회전                                                              |
| `color()`                                      | 펜의 색 지정                                                                 |
| `circle(반지름)`                               | 원 그리기                                                                    |
| `begin_fill()`                                 | 색칠할 영역 시작                                                             |
| `end_fill()`                                   | 색칠할 영역 끝                                                               |
| `speed('속도')`<br>`speed()`                   | 거북이 속도 설정<br>거북이 속도 확인                                         |

<br><br>



# UNIT 22~24

<br>

리스트 메서드
-------------

| 메서드                           | 설명                                                                                                                                            |
| -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| `append(값)`                     | 리스트 끝에 값을 추가. `리스트[len(리스트):] = [값]`과 같음                                                                                     |
| `append(리스트)`                 | 리스트를 넣으면 리스트 안에 리스트가 들어감                                                                                                     |
| `extend(리스트)`                 | 리스트 끝에 다른 리스트 연결, `리스트[len(리스트)] = [값, 값]`과 같음                                                                           |
| `insert(인덱스, 값)`             | 리스트 특정 인덱스에 값을 추가                                                                                                                  |
| `pop()`<br>`pop(인덱스)`         | 리스트의 마지막 값을 삭제한 뒤 삭제한 값을 반환<br>인덱스를 지정하면 해당 인덱스의 값을 삭제한 뒤 삭제한 값을 반환, `del 리스트[인덱스]`와 같음 |
| `remove(값)`                     | 리스트에서 특정 값을 삭제                                                                                                                       |
| `index(값)`                      | 리스트에서 특정 값의 인덱스를 구함                                                                                                              |
| `count(값)`                      | 리스트에서 특정 값의 개수를 구함                                                                                                                |
| `reverse()`                      | 리스트에서 값의 순서를 반대로 뒤집음                                                                                                            |
| `sort()`<br>`sort(reverse=True)` | 리스트의 값을 작은 순서대로 정렬(오름차순)<br>`reverse=True`는 큰 순서대로 정렬                                                                 |
| `clear()`                        | 리스트의 모든 값을 삭제, `del a[:]`와 같음                                                                                                      |
| `copy()`                         | 리스트를 복사하여 새 리스트 생성                                                                                                                |

튜플은 값의 정보를 구하는 `index`, `count` 메서드만 사용할 수 있다.

<br>

인덱스로 범위를 지정하여 리스트 조작하기
----------------------------------------

리스트는 메서드를 사용하지 않고 인덱스로 범위를 지정하여 조작할 수 있다.

```python
리스트[len(리스트):] = [값]         # 리스트 끝에 값이 한 개 들어있는 리스트 추가
                                    # 리스트.append(값)과 같음
리스트[len(리스트):] = [값, 값]     # 리스트 끝에 다른 리스트 연결
                                    # 리스트.extend([값, 값])과 같음
del 리스트[인덱스]                  # 특정 인덱스의 값 삭제, 리스트.pop(인덱스)와 같음
del 리스트[:]                       # 시작 인덱스와 끝 인덱스를 생략하여 리스트의 모든 값을 삭제
                                    # 리스트.clear()와 같음
```

<br>

리스트(튜플)와 반복문
---------------------

`for 변수 in` 뒤에 리스트(튜플)을 지정하면 반복하면서 모든 요소를 꺼내온다. 특히 `enumerate(리스트)`를 지정하면 인덱스와 요소를 동시에 꺼내올 수 있다.

```python
for 변수 in 리스트:                         # 반복하면서 요소를 꺼내옴
    반복할 코드

for 인덱스, 요소 in enumerate(리스트):      # 반복하면서 인덱스와 요소를 꺼내옴
    반복할 코드

for 인덱스 in range(len(리스트)):           # 리스트의 길이로 반복
    리스트[인덱스]                          # 인덱스로 요소에 접근

while 인덱스 < len(리스트):                 # 리스트의 길이로 반복
    리스트[인덱스]                          # 인덱스로 요소에 접근
    인덱스 += 1
```

<br>

`min`, `max`, `sum` 함수
------------------------

`min`은 리스트(튜플)에서 가장 작은 값, `max`는 가장 큰 값, `sum`은 요소의 합계를 구한다.

<br>

리스트(튜플) 표현식
-------------------

리스트(튜플) 표현식은 리스트 안에 식, `for` 반복문, `if` 조건문 등을 지정하여 리스트(튜플)를 생성한다.

```python
# 리스트 표현식
[식 for 변수 in 리스트]
[i for i in range(10)]
list(식 for 변수 in 리스트)

# 튜플 표현식
tuple(식 for 변수 in 리스트 if 조건식)

# if 조건문 사용
[식 for 변수 in 리스트 if 조건식]
[i for i in range(10) if i % 2 == 0]
list(식 for 변수 in 리스트 if 조건식)
```

```python
[식 for 변수1 in 리스트1 if 조건식1
    for 변수2 in 리스트2 if 조건식2
    ...
    for 변수n in 리스트n if 조건식n]
[i * j for in range(2, 10) for in range(1, 10)]

list(식 for 변수1 in 리스트1 if 조건식1
        for 변수2 in 리스트2 if 조건식2
        ...
        for 변수n in 리스트n if 조건식n)
```

<br>

리스트(튜플)에 `map` 함수 사용
------------------------------

`map`은 리스트(튜플)의 요소를 지정된 함수로 처리해주는 함수이다.

```python
리스트 = list(map(함수, 리스트))
a = list(map(int, a))
튜플 = tuple(map(함수, 튜플))

변수1, 변수2 = list(map(함수, 리스트))      # 언패킹 사용
a, b = list(map(str, range(2)))

변수1, 변수2 = map(함수, 리스트)            # 언패킹 사용
a, b = map(int, input().split())
```

<br>

2차원 리스트
------------

2차원 리스트는 가로×세로의 평면 구조로 이루어져 있다. 2차원 리스트는 리스트 안에 리스트를 넣어서 만들 수 있으며 안쪽의 각 리스트는 `,`(콤마)로 구분해준다. 2차원 리스트의 요소에 접근하거나 할당할 때는 리스트에 `[]`(대괄호)를 두 번 사용하며 `[]` 안에 세로 인덱스와 가로 인덱스를 지정해준다. 일반적으로 2차원 공간은 가로×세로로 표기하지만 리스트로 만들 때는 세로×가로로 표기한다.

```python
리스트 = [[값, 값], [값, 값], [값, 값]]     # 2차원 리스트 만들기

리스트[세로인덱스][가로인덱스]              # 2차원 리스트의 요소에 접근
리스트[세로인덱스][가로인덱스] = 값         # 2차원 리스트의 요소에 값 저장

리스트 = [(값, 값), (값, 값), (값, 값)]     # 리스트 안에 튜플을 넣음
튜플 = ([값, 값], [값, 값], [값, 값])       # 튜플 안에 리스트를 넣음
튜플 = ((값, 값), (값, 값), (값, 값))       # 튜플 안에 튜플을 넣음
```

<br>

3차원 리스트
------------

3차원 리스트는 높이×세로×가로 형태로 이루어져 있다. 3차원 공간은 가로×세로×높이로 표기하지만 리스트로 만들 때는 높이×세로×가로로 표기한다.

```python
리스트 = [[[값, 값], [값, 값]], [[값, 값], [값, 값]], [[값, 값], [값, 값]]]     # 3차원 리스트 만들기
리스트[높이인덱스][세로인덱스][가로인덱스]                                      # 3차원 리스트의 요소에 접근
리스트[높이인덱스][세로인덱스][가로인덱스] = 값                                 # 3차원 리스트의 요소에 값 저장
```

<br>

문자열 메서드
-------------

| 메서드                                                                                                               | 설명                                                                                                                                           |
| -------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `replace('바꿀문자열', '새문자열')`                                                                                  | 문자열 안의 문자열을 다른 문자열로 바꿈                                                                                                        |
| `translate(테이블)`                                                                                                  | 문자열 안의 문자를 다른 문자로 바꿈, `str.maketrans('바꿀문자', '새문자')로 변환 테이블을 만들어야 함                                          |
| `split()`<br>`split('기준문자열')`                                                                                   | 공백을 기준으로 문자열을 분리하여 리스트로 만듦<br>기준 문자열을 지정하면 기준 문자열로 문자열을 분리                                          |
| `join(리스트)`                                                                                                       | 구분자 문자열과 문자열 리스트(튜플)의 요소를 연결하여 문자열로 만듦                                                                            |
| `upper()`<br>`lower()`                                                                                               | `upper`는 문자열의 문자를 대문자로 바꾸고, `lower`는 소문자로 바꿈                                                                             |
| `lstrip()`, `rstrip()`, `strip()`<br>`lstrip('삭제할문자들')`<br>`rstrip('삭제할문자들')`<br>`strip('삭제할문자들')` | `lstrip`은 문자열에서 왼쪽 공백을 삭제, `rstrip`은 오른쪽 공백을 삭제, `strip`은 양쪽 공백을 삭제, 삭제할 문자들을 지정하면 해당 문자들을 삭제 |
| `ljust(길이)`, `rjust(길이)`, `center(길이)`                                                                         | 문자열을 지정된 길이로 만든 뒤 왼쪽(`ljust`), 오른쪽(`rjust`), 가운데(`center`)로 정렬하며 남는 공간은 공백으로 채움                           |
| `zfill()`                                                                                                            | 지정된 길이에 맞춰서 문자열의 왼쪽에 0을 채움                                                                                                  |
| `find('찾을문자열')`<br>`rfind('찾을문자열')`                                                                        | `find`는 왼쪽에서부터, `rfind`는 오른쪽에서부터 특정 문자열을 찾아서 인덱스 반환, 문자열이 없으면 -1을 반환                                    |
| `index('찾을문자열')`<br>`rindex('찾을문자열')`                                                                      | `index`는 왼쪽에서부터, `rindex`는 오른쪽에서부터 특정 문자열을 찾아서 인덱스를 반환, 문자열이 없으면 에러 발생                                |
| `count('문자열')`                                                                                                    | 현재 문자열에서 특정 문자열이 몇 번 나오는지 알아냄                                                                                            |

<br>

문자열 서식 지정자
------------------

문자열은 서식 지정자를 조합하여 문자열을 만들 수 있다. 서식 지정자는 `%`로 시작하여 자료형을 뜻하는 문자가 붙는다. 서식 지정자를 사용한 뒤 `%` 다음에 문자열을 지정하주면 이 문자열이 서식 지정자에 들어간다. 서식 지정자가 여러 개일 때는 값 여러 개를 튜플로 만들어서 지정해준다.

* `%s`: 문자열
* `%d`: 정수
* `%f`: 실수

```python
'%서식지정자' % 값                          # 서식 지정자 한 개 사용
'I am %s.' % 'maria'                        # 'I am maria.'

'%서식지정자1, %서식지정자2' % (값1, 값2)   # 서식 지정자 여러 개 사용
'Today is %d %s.' % (3, 'April')            # 'Today is 3 April.'
```

소수점 이하 자릿수를 지정하고 싶다면 `f` 앞에 `.`(점)과 자릿수를 지정한다.

```python
'%.자릿수f' % 숫자      # 소수점 이하 자릿수 지정하기
'%.3f' % 2.3            # '2.300'
```

`%`뒤에 숫자를 붙이면 문자열을 지정된 길이로 만든 뒤 오른쪽으로 정렬하고 남은 공간을 공백으로 채운다. 길이를 음수로 지정하면 왼쪽으로 정렬한다.

```python
%길이s                  # 문자열을 지정된 길이로 만든 뒤 오른쪽으로 정렬하고 남는 공간을 공백으로 채움
'$10s' % 'python'       # '    python'

%-길이s                 # 문자열을 지정된 길이로 만든 뒤 왼쪽으로 정렬하고 남는 공간을 공백으로 채움
'%-10s' % 'python'      # 'python    '
```

`%`와 `d`사이에 0과 숫자 개수를 넣으면 자릿수에 맞춰서 앞에 0이 들어간다.

```python
'%0개수d' % 숫자            # 자릿수에 맞춰서 0이 들어감
'%03d' % 1                  # '001'

'%0개수.자릿수f' % 숫자     # 실수의 소수점 이하 자릿수 지정
'%08.2f' % 3.6              # '00003.60'
```

<br>

문자열 포매팅
-------------

문자열 포매팅을 사용할 때는 `{}`(중괄호) 안에 인덱스를 지정하고, `format`에는 `{}` 부분에 들어갈 값을 지정해준다.

```python
'{0}'.format(값)                                    # 값을 한 개 넣음
'{0} {1}'.format(값1, 값2)                          # 값을 두 개 넣음
'{0} {0} {1} {1}'.format(값1, 값2)                  # 같은 인덱스에는 같은 값이 들어감
'{} {} {}'.format(값1, 값2, 값3)                    # 인덱스를 생략하면 format에 지정한 순서대로 값이 들어감
'{name1} {name2}'.format(name1=값1, name2=값2)      # {}에 이름을 지정
```

파이썬 3.6부터는 변수에 값을 넣고 `{}` 안에 변수 이름을 지정하면 된다. 이때는 문자열 앞에 `f`를 붙인다.

```python
변수1, 변수2 = 값1, 값2
f'{변수1} {변수2}'
```

문자열 포매팅에서 `<`은 문자열을 지정된 길이로 만든 뒤 왼쪽으로 정렬하고 남는 공간을 공백으로 채운다. `>`은 오른쪽으로 정렬한다.

```python
'{인덱스:<길이}'.format(값)     # 문자열을 지정된 길이로 만든 뒤 왼쪽 정렬, 남는 공간을 공백으로 채움
'{인덱스:>길이}'.format(값)     # 문자열을 지정된 길이로 만든 뒤 오른쪽 정렬, 남는 공간을 공백으로 채움
```

문자열 포매팅에서 인덱스나 이름 뒤에 `:`(콜론)을 붙이고 0과 숫자 개수를 지정하면 맞춰서 0이 들어간다.

```python
'{인덱스:0개수d}'.format(숫자)              # 자릿수에 맞춰서 0이 들어감
'{인덱스:0개수.자릿수f'}.format(숫자)       # 실수의 소수점 이하 자릿수 지정
```

문자열 포매팅은 채우기, 정렬, 길이, 자릿수, 자료형을 조합하여 사용할 수 있다.

```python
'{인덱스:[[채우기]정렬][길이][.자릿수][자료형]}'

'{0:0<10}'.format(15)       # '1500000000': 길이 10, 왼쪽으로 정렬하고 남는 공간은 0으로 채움
'{0:0>10.2f}'.format(15)    # '0000015.00': 길이 10, 오른쪽으로 정렬하고 소수점 이하 자릿수는 2자리
'{0: >10}'.format(15)       # '        15': 남는 공간을 공백으로 채움
'{0:>10}'.format(15)        # '        15': 채우기 부분을 생략하면 공백이 들어감
'{0:x>10}'.format(15)       # 'xxxxxxxx15': 남는 공간을 문자 x로 채움
```

<br>

서식 지정자 자료형
------------------

| 자료형 | 설명                                                                                                          |
| ------ | ------------------------------------------------------------------------------------------------------------- |
| `s`    | 문자열                                                                                                        |
| `b`    | 2진수                                                                                                         |
| `c`    | 문자                                                                                                          |
| `d`    | 10진 정수                                                                                                     |
| `o`    | 8진 정수, 예) `'%o' % 8`은 `'10'`                                                                             |
| `x`    | 16진 정수, `0`~`9`, `a`~`f`, 예) `'%x' % 254`는 `'fe'`                                                        |
| `X`    | 16진 정수, `0`~`9`, `A`~`F`, 예) `'%X' % 254`는 `'FE'`                                                        |
| `e`    | 실수 지수 표기법, 예) `'%e' % 2.3`은 `'2.300000e+00'`                                                         |
| `E`    | 실수 지수 표기법, 예) `'%E' % 2.3`은 `'2.300000E+00'`                                                         |
| `f`    | 실수 소수점 표기                                                                                              |
| `F`    | 실수 소수점 표기, `f`와 같음, `nan`은 `NAN`, `inf`는 `INF`로 표시(`nan`은 숫자가 아니라는 뜻, `inf`는 무한대) |
| `g`    | 실수 일반 형식, 예) `'%g' % 2.3e-10`은 `'2.3e-10'`                                                            |
| `G`    | 실수 일반 형식, 예) `'%G' % 2.3ㄷ-10`은 `'2.3E-10'`                                                           |
| `%`    | `%` 문자 표시                                                                                                 |

<br>

변경이 불가능한 튜플은 왜 사용하나?
-----------------------------------

리스트는 언제든지 요소를 추가하기 위해 실제 데이터보다 더 큰 메모리를 사용한다. 하지만 튜플은 요소를 변경하지 않으므로 고정된 메모리 공간을 사용한다. 또한, 튜플이 리스트보다 구조가 간단하므로 속도가 훨씬 빠르다. 따라서 요소가 변경되지 않는 곳에는 튜플을 사용하면 메모리를 아낄 수 있고 성능도 높일 수 있다.

<br><br>



# UNIT 25~26

<br>

딕셔너리 메서드
---------------

| 메서드                                                                                                  | 설명                                                                                                                                           |
| ------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `setdefault(키, 기본값)`                                                                                | 딕셔너리에 키-값 쌍을 추가, 키만 지정하면 값에 `None`을 저장                                                                                   |
| `update(키=값)`<br>`update(딕셔너리)`<br>`update(리스트)`<br>`update(튜플)`<br>`update(반복가능한객체)` | 딕셔너리에서 키의 값을 수정, 딕셔너리에 키가 없으면 키-값 쌍을 추가                                                                            |
| `pop(키)`<br>`pop(키, 기본값)`                                                                          | 딕셔너리에서 키-값 쌍을 삭제한 뒤 값을 반환, `del 딕셔너리[키]`와 같음<br>기본값을 지정하면 키가 없을 때 기본값을 반환                         |
| `popitem()`                                                                                             | 딕셔너리에서 임의의 키-값 쌍을 삭제하고 해당 키-값 쌍을 튜플로 반환                                                                            |
| `clear()`                                                                                               | 딕셔너리의 모든 키-값 쌍을 삭제                                                                                                                |
| `get(키)`<br>`get(키, 기본값)`                                                                          | 딕셔너리에서 특정 키의 값을 가져옴<br>기본값을 지정하면 키가 없을 때 기본값을 반환                                                             |
| `items()`<br>`keys()`<br>`values()`                                                                     | `items`는 딕셔너리의 키-값 쌍을 모두 가져옴<br>`keys`는 딕셔너리의 키를 모두 가져옴<br>`values`는 딕셔너리의 값을 모두 가져옴                  |
| `copy()`                                                                                                | 딕셔너리를 복사하여 새 딕셔너리 생성                                                                                                           |
| `dict.fromkeys(키리스트)`<br>`dict.fromkeys(키리스트, 값)`                                              | 리스트(튜플)로 딕셔너리를 만듦, 키 리스트만 지정하면 값은 모두 `None`이 저장됨<br>키 리스트와 값을 지정하면 해당 값이 딕셔너리의 값으로 저장됨 |

<br>

딕셔너리와 반복문
-----------------

`for 변수 in` 뒤에 딕셔너리를 지정하면 키만 꺼내온다. 그리고 `for in`뒤에 딕셔너리를 지정하고 `items`를 사용하면 반복하면서 모든 키와 값을 꺼내오고, `keys`는 키, `values`는 값만 꺼내온다.

```python
for 변수 in 딕셔너리:               # 모든 키를 꺼내옴
    반복할 코드

for 키, 값 in 딕셔너리.items():     # 모든 키와 값을 꺼내옴
    반복할 코드

for 키 in 딕셔너리.keys():          # 모든 키를 꺼내옴
    반복할 코드

for 값 in 딕셔너리.values():        # 모든 값을 꺼내옴
    반복할 코드
```

<br>

딕셔너리 표현식
---------------

딕셔너리 표현식은 딕셔너리 안에 식, `for` 반복문, `if` 조건문 등을 지정하여 딕셔너리를 생성한다.

```python
{키: 값 for 키, 값 in 딕셔너리}
{key: value for key, value in dict.fromkeys(['a', 'b', 'c', 'd']).items()}
dict(키: 값 for 키, 값 in 딕셔너리)

{키: 값 for 키, 값 in 딕셔너리 if 조건식}
{key: value for key, value in {'a': 10, 'b': 20, 'c': 30, 'd': 40}.items() if value != 20}
dict(키: 값 for 키, 값 in 딕셔너리 if 조건식)
```

<br>

세트
----

세트는 집합 형태의 자료형이다. `{}`(중괄호) 안에 값을 저장하며 각 값은 `,`(콤마)로 구분해준다. 단, 세트는 `[]`(대괄호)로 특정 요소를 출력할 수 없다.

```python
세트 = {값1, 값2, 값3}          # 세트 만들기
세트 = set(반복가능한객체)      # 세트 만들기

값 in 세트                      # 세트에 특정 값이 있는지 확인
값 not in 세트                  # 세트에 특정 값이 없는지 확인

len(세트)                       # 세트의 요소 개수(길이) 구하기
```

<br>

세트의 메서드와 집합 연산
-------------------------

| 메서드                                   | 집합 연산자 | 설명                                                             |
| ---------------------------------------- | ----------- | ---------------------------------------------------------------- |
| `set.union(세트1, 세트2)`                | `|`         | 두 세트의 합집합                                                 |
| `set.intersection(세트1, 세트2)`         | `&`         | 두 세트의 교집합                                                 |
| `set.difference(세트1, 세트2)`           | `-`         | 두 세트의 차집합                                                 |
| `set.symmetric_difference(세트1, 세트2)` | `^`         | 두 세트의 대칭차집합                                             |
| `update(다른세트)`                       | `|=`        | 현재 세트에 다른 세트를 더함                                     |
| `intersection_update(다른세트)`          | `&=`        | 현재 세트와 다른 세트 중에서 겹치는 요소만 저장                  |
| `diffrence_update(다른세트)`             | `-=`        | 현재 세트에서 다른 세트를 뺌                                     |
| `symmetric_diffrence_update(다른세트)`   | `^=`        | 현재 세트와 다른 세트 중에서 겹치지 않는 요소만 현재 세트에 저장 |
| `issubset(다른세트)`                     | `<=`        | 현재 세트가 다른 세트의 부분집합인지 확인                        |
|                                          | `<`         | 현재 세트가 다른 세트의 진부분집합인지 확인                      |
| `issuperset(다른세트)`                   | `>=`        | 현재 세트가 다른 세트의 상위집합인지 확인                        |
|                                          | `>`         | 현재 세트가 다른 세트의 진상위집합인지 확인                      |
| `isdisjoint(다른세트)`                   |             | 현재 세트가 다른 세트와 겹치지 않는지 확인                       |
| `add(요소)`                              |             | 세트에 요소를 추가                                               |
| `remove(요소)`                           |             | 세트에서 특정 요소를 삭제, 없으면 에러 발생                      |
| `discard(요소)`                          |             | 세트에서 특정 요소를 삭제, 요소가 없으면 그냥 넘어감             |
| `pop()`                                  |             | 세트에서 임의의 요소를 삭제하고 해당 요소를 반환                 |
| `clear()`                                |             | 세트에서 모든 요소를 삭제                                        |
| `copy()`                                 |             | 세트를 복사하여 새로운 세트 생성                                 |

<br>

세트와 반복문
-------------

`for 변수 in` 뒤에 세트를 지정하면 반복하면서 모든 요소를 꺼내온다.

```python
for 변수 in 세트:
    반복할 코드
```

<br>

세트 표현식
-----------

세트 표현식은 세트 안에 식, `for` 만복문, `if` 조건문 등을 지정하여 세트를 생성한다.

```python
{식 for 변수 in 반복가능한값}
{i for i in 'apple'}
set(식 for 변수 in 반복가능한값)
{식 for 변수 in 세트 if 조건식}
{i for i in 'pineapple' if i not in 'apl'}
set(식 for 변수 in 세트 if 조건식)
```

<br>

딕셔너리를 더하려면 어떻게 해야 하나?
-------------------------------------

딕셔너리는 `+` 연산자로 더할 수 없지만 update 메서드를 사용하면 `+`로 더한 것과 같은 효과를 낼 수 있다. 즉, update에 딕셔너리를 넣을 수 있고 키가 없으면 키를 추가하는 특성을 이용한 것이다.

```python
>>> x = {'a': 1, 'b': 2}
>>> y = {'c': 3, 'd': 4}
>>> x.update(y)
>>> x
{'a': 1, 'b': 2, 'c': 3, 'd': 4}
```

파이썬 3.5 이상부터는 딕셔너리 언패킹을 이용한 병합을 지원한다.

* `{**딕셔너리, **딕셔너리}`

```python
>>> {**x, **y}
{'a': 1, 'b': 2, 'c': 3, 'd': 4}
```

<br>

딕셔너리와 세트는 `while`로 반복할 수 있나?
-------------------------------------------

딕서너리와 세트를 `while`로 반복하려면 조금 복잡하다. 다음과 같이 딕셔너리와 세트에서 이터레이터를 얻은 뒤에 `next`로 요소를 차례대로 꺼내면 된다.

```python
x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}                            # 딕셔너리
#x = {'strawberry', 'grape', 'orange', 'pineapple', 'cherry'}       # 세트
it = iter(x)                    # 이터레이터를 얻음
while True:
    try:
        print(x[next(it)])      # 딕셔너리에 키를 지정해서 값 출력
        #print(next(it))        # 세트의 요소 출력
    except StopIteration:
        break
```

<br><br>



# UNIT 27~28

<br>

파일 열기, 닫기
---------------

파일 읽기/쓰기를 하기 전에는 `open` 함수로 파일을 열어서 파일 객체를 얻어야 한다. 그 다음에 파일 읽기/쓰기 작업이 끝났다면 반드시 `close`로 파일 객체를 닫아준다.

```python
파일객체 = open(파일이름, 파일모드)             # 파일 열기
파일객체.close()                                # 파일 객체 닫기

with open(파일이름, 파일모드) as 파일객체:      # 파일을 사용한 뒤 자동으로 파일 객체를 닫아줌
    코드
```

<br>

파일 모드
---------

파일을 열 때는 용도에 따라 다양한 파일 모드를 지정해야 한다.

| 파일 모드 | 기능                   | 설명                                                                                                                                      |
| --------- | ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `'r'`     | 읽기 전용              | 파일을 읽기 전용으로 열기. 단, 파일이 반드시 있어야 하며 파일이 없으면 에러 발생                                                          |
| `'w'`     | 쓰기 전용              | 쓰기 전용으로 새 파일을 생성, 만약 파일이 있으면 내용을 덮어씀                                                                            |
| `'a'`     | 추가                   | 파일을 열어 끝에 값을 이어 씀. 만약 파일이 없으면 파일을 생성                                                                             |
| `'x'`     | 배타적 생성(쓰기)      | 파일을 쓰기 모드로 생성. 파일이 이미 있으면 에러 발생                                                                                     |
| `'r+'`    | 읽기/쓰기              | 파일을 읽기/쓰기용으로 열기. 단, 파일이 반드시 있어야 하며 파일이 없으면 에러 발생                                                        |
| `'w+'`    | 읽기/쓰기              | 파일을 읽기/쓰기용으로 열기. 파일이 없으면 파일을 생성하고, 파일이 있으면 내용을 덮어씀                                                   |
| `'a+'`    | 추가(읽기/쓰기)        | 파일을 열어 파일 끝에 값을 이어 씀. 만약 파일이 없으면 파일을 생성. 읽기는 파일의 모든 구간에서 가능하지만, 쓰기는 파일의 끝에서만 가능함 |
| `'x+'`    | 배타적 생성(읽기/쓰기) | 파일을 읽기/쓰기 모드로 생성. 파일이 이미 있으면 에러 발생                                                                                |
| `t`       | 텍스트 모드            | 파일을 읽거나 쓸 때 개행 문자 `\n`과 `\r\n`을 서로 변환<br>`t`를 생략하면 텍스트 모드                                                     |
| `b`       | 바이너리 모드          | 파일의 내용을 그대로 읽고, 값을 그대로 씀                                                                                                 |

<br>

파일 메서드
-----------

| 메서드                        | 설명                                                                     |
| ----------------------------- | ------------------------------------------------------------------------ |
| `read()`                      | 파일에서 문자열을 읽음                                                   |
| `write('문자열')`             | 파일에 문자열을 씀                                                       |
| `readline()`                  | 파일의 내용을 한 줄 읽음                                                 |
| `readlines()`                 | 파일의 내용을 한 줄씩 리스트 형태로 가져옴                               |
| `writelines(문자열리스트)`    | 파일에 리스트의 문자열을 씀, 리스트의 각 문자열에는 `\n`을 붙여주어야 함 |
| `pickle.load(파일객체)`       | 파일에서 파이썬 객체를 읽음                                              |
| `pickle.dump(객체, 파일객체)` | 파이썬 객체를 파일에 저장                                                |

<br>

파일을 연 뒤에는 왜 파일을 닫아야 하나?
---------------------------------------

파이썬에는 사용이 끝난 메모리를 정리해주는 가비지 컬렉터가 있어서 파일을 닫지 않아도 가비지 컬렉터가 파일을 닫아준다. 하지만 프로그래머가 파일을 직접 닫아야 하는 이유는 다음과 같다.

* 너무 많은 파일을 열어 두면 그만큼 메모리 공간을 차지하므로 성능에 영향을 줄 수 있다.
* 파일을 닫지 않으면 데이터가 쓰기가 와나료되지 않을 수도 있다. 운영체제는 파일을 처리할 때 성능을 위해서 데이터를 임시 버퍼(임시 공간)에 저장한 뒤 파일에 쓴다. 때에 따라서는 파일이 닫히는 시점에 버퍼의 내용이 파일에 저장된다.
* 이론적으로 운영체제에서 열 수 있는 파일의 개수는 한계가 있다.
* 운영체제에 따라 파일을 열었을 때 파일을 잠금 상태로 처리하는 경우가 있다. 실질적으로 파일 처리가 끝났더라도 파일을 닫지 않으면 다른 프로그램에서 파일을 사용할 수 없는 상태가 된다.

보통은 파일을 닫지 않아도 큰 문제가 없다. 하지만 실무에서는 사소한 실수로도 큰 문제가 발생하는 경우가 있으므로 파일을 정확히 닫는 습관을 기르는 것이 좋다. 파이썬에서는 주로 `with as`를 사용하여 파일을 자동으로 닫는 방식을 사용한다.

<br><br>



# UNIT 29~

함수
----

함수는 자주 사용하는 코드를 한 곳에 모아 놓은 것을 뜻한다.

```python
def 함수이름():     # 함수 만들기
    코드

함수()              # 함수 호출
```

함수를 호출할 때 함수 안에 넣는 값을 인수라고 하며 인수는 매개변수를 통해서 사용할 수 있다. 그리고 함수가 호출된 뒤 함수 안에서 나오는 값을 반환값이라고 하며 반환값은 함수 안에서 `return`으로 반환한다.

```python
def 함수이름(매개변수1, 매개변수2):     # 매개변수 지정
    return 반환값                       # 함수에서 값 반환

변수 = 함수(인수1, 인수2)               # 함수에 인수를 넣어서 호출한 뒤 함수의 반환값을 변수에 저장
```

<br>

매개변수와 인수
---------------

함수 바깥에서 전달받은 값이 저장되는 변수를 매개변수라고 부른다.

```python
def add(a, b):          # a와 b가 매개변수
    return a + b
```

함수를 호출할 때 전달하는 값이나 변수를 인수라고 부른다.

```python
add(10, 20)     # 10과 20이 인수
```

<br>

함수에서 값을 여러 개 반환하기
------------------------------

함수에서 값을 여러 개 반환할 때는 `return`에 값이나 변수를 `,`(콤마)로 구분해서 지정한다. 이렇게 하면 반환값을 변수 여러 개에 저장할 수 있다.

```python
def 함수이름(매개변수):
    return 반환값1, 반환값2     # 값을 여러 개 반환

변수1, 변수2 = 함수(인수)       # 반환값을 변수 여러 개에 저장
```

<br>

위치 인수
---------

함수에 인수를 순서대로 넣는 방식을 위치 인수라고 한다. 위치 인수를 사용하는 함수는 리스트(튜플) 앞에 `*`(애스터리스크)를 붙여서 리스트 언패킹으로 넣을 수 있다.

```python
def 함수이름(매개변수1, 매개변수2):     # 위치 인수를 사용하는 함수
    코드

함수(*리스트)                           # 리스트 언패킹
함수(*튜플)                             # 튜플 언패킹
```

위치 인수를 사용하는 가변 인수 함수는 매개변수 앞에 `*`를 붙여서 만든다.

```python
def 함수이름(*매개변수):        # 위치 인수를 사용하는 가변 인수 함수
    코드

함수(인수1, 인수2)              # 인수 여러 개를 직접 넣기
함수(*리스트)                   # 리스트 언패킹
함수(*튜플)                     # 튜플 언패킹
```



키워드 인수
===========

함수에 넣는 인수에 이름(키워드)를 붙이는 방식을 키워드 인수라고 한다. 키워드 인수는 딕셔너리 앞에 `**`(애스터리스크 두 개)를 붙여서 딕셔너리 언패킹으로 넣을 수 있다.

```python
함수(키워드1=값1, 키워드2=값2)      # 함수를 키워드 인수 방식으로 호출

함수(**딕셔너리)                    # 딕셔너리 언패킹
```

키워드 인수를 사용하는 가변 인수 함수는 매개변수 앞에 `**`를 붙여서 만든다.

```python
def 함수이름(**매개변수):           # 키워드 인수를 사용하는 가변 인수 함수
    코드

함수(키워드1=값1, 키워드2=값2)      # 키워드 인수를 직접 넣기
함수(**딕셔너리)                    # 딕셔너리 언패킹
```



매개변수의 초깃값
=================

함수를 만들 때 매개변수에 초깃값을 지정하면 함수를 호출할 때 해당 인수를 비워드고 호출할 수 있다.

```python
def 함수이름(매개변수=값):      # 매개변수에 초깃값 저장
    코드

함수()                          # 매개변수에 초깃값이 있으므로 인수를 비워두고 호출
```



함수의 재귀호출
===============

함수 안에서 함수 자기 자신을 호출하는 방식을 재귀호출이라 한다.

```python
def factorial(n):                       # 재귀호출로 팩토리얼을 구하는 함수
    if n == 1:                          # n이 1일 때
        return 1                        # 1을 반환하고 재귀호출을 끝냄
    return n * (factorial(n - 1))       # n과 factorial 함수에 n - 1을 넣어서 반환된 값을 곱함
```

재귀호출은 반드시 종료 조건을 만들어주어야 한다. 종료 조건이 없으면 함수가 계속 호출되다가 RecursionError가 발생한다.



람다 표현식
===========

람다 표현식은 간단한 식으로 함수를 만들 때 사용한다. 특히 람다 표현식으로 만든 함수는 이름이 없어서 익명 함수라고 부르기도 한다. 람다 표현식 자체를 호출하려면 람다 표현식 `()`(괄호)로 묶은 뒤 다시 `()`를 붙이고 인수를 넣어서 호출한다.

```python
lambda 매개변수1, 매개변수2: 반환값                                         # 람다 표현식으로 함수를 만듦
(lambda 매개변수1, 매개변수2: 반환값)(인수1, 인수2)                         # 람다 표현식 자체를 호출

lambda 매개변수1, 매개변수2: 식1 if 조건식 else 식2                         # 람다 표현식에서 조건부 표현식 사용
lambda x: str(x) if x % 3 == 0 else x

lambda 매개변수1, 매개변수2: 식1 if 조건식1 else 식2 if 조건식2 else 식3    # if를 여러 개 사용
lambda x: str(x) if x == 1 else float(x) if x == 2 else x + 10
```



변수의 사용 범위
================

전역 변수는 스크립트 전체에서 접근할 수 있으며 지역 변수는 해당 변수 안에서만 접근할 수 있다. 만약 함수 안에서 전역 변수를 사용하려면 `global`에 변수 이름을 지정해준다.

```python
x = 10          # 전역 변수

def foo():
    global x    # 전역 변수 x를 사용하겠다고 설정
    y = 10      # foo의 지역 변수
```

만약 전역 변수가 없을 때 함수 안에서 `global`을 사용하면 해당 변순느 전역 변수가 된다.



함수 안에서 함수 사용하기
=========================

파이썬에서는 `def`로 함수를 만들고 다시 `def`로 함슬 만들 수 있다.

```python
def 함수이름1():
    코드
    def 함수이름2():
        코드
```

함수 안에 함수를 만들었을 때 안쪽 함수에서 바깥쪽 함수의 지역 변수를 변경하려면 `nonlocal`에 변수 이름을 지정해준다.

```python
def A():
    x = 10              # A의 지역 변수 x
    def B():
        nonlocal x      # 현재 함수에서 바깥쪽에 있는 지역변수를 사용
        x = 20          # A의 지역 변수 x에 20 할당
```



클로저
======

클로저는 함수를 둘러싼 환경(지역 변수, 코드 등)을 계속 유지하다가 함수를 호출할 때 다시 꺼내서 사용하는 함수를 뜻한다. 따라서 클로저는 지역 변수와 코드를 묶어서 사용하고 싶을 때 활용한다. 또한, 클로저에 속한 지역 변수는 바깥에서 직접 접근할 수 없으므로 데이터를 숨기고 싶을 때 활용한다.

```python
def calc():                             # calc 함수 안에 mul_add 함수를 만듦
    a = 3
    b = 5
    def mul_add(x):
        return a * x + b                # 함수 바깥쪽에 있는 지역 변수 a, b를 사용하여 계산
    return mul_add                      # mul_add 함수를 반환

c = calc()                              # c에 저장된 함수가 클로저
print(c(1), c(2), c(3), c(4), c(5))     # 8 11 14 17 20
```

클로저는 람다 표현식으로도 만들 수 있다.

```python
def calc():
    a = 3
    b = 5
    return lambda x: a * x + b      # 람다 표현식을 반환
```



람다와 클로저
=============

보통 클로저는 람다와 함께 사용하는 경우가 많아 둘을 혼동하기 쉽다. 람다는 이름이 없는 익명 함수를 뜻하고, 클로저는 함수를 둘러싼 환경을 유지했다가 나중에 다시 사용하는 함수를 뜻한다.



클래스
======

클래스는 객체를 표현하기 위한 문법이다. 클래스는 `class`에 클래스 이름을 지정하고 `:`(콜론)을 붙인 뒤 다음 줄부터 `def`로 메서드를 작성한다. 메서드는 클래스 안에 들어있는 함수를 뜻한다.

```python
class 클래스이름:           # 클래스 만들기
    def 메서드(self):       # 메서드 만들기
        코드
```

클래스는 `()`(괄호)를 붙인 뒤 변수에 할당하여 인스턴스(객체)를 만든다. 그리고 인스턴스 뒤에 `.`(점)을 붙여서 메서드를 호출한다.

```python
인스턴스 = 클래스()     # 인스턴스(객체) 만들기
인스턴스.메서드         # 인스턴스로 메서드 호출
```



클래스의 속성
=============

클래스에 인스턴스 속성을 만들 때는 `__init__` 메서드 안에서 `self.속성`에 값을 할당해준다. 그리고 인스턴스 속성에 접근할 때는 메서드 안에서 `self` 뒤에 `.`(점)을 붙여서 접근하거나, 인스턴스 뒤에 `.`을 붙여서 접근한다.

```python
class 클래스이름:
    def __init__(self):
        self.속성 = 값      # 인스턴스 속성 만들기

    def 메서드(self):
        self.속성           # self 뒤에 .을 붙여서 인스턴스 속성에 접근

인스턴스 = 클래스()         # 인스턴스(객체) 만들기
인스턴스.속성               # 인스턴스 속성에 접근
```

클래스에 바로 속성을 만들면 클래스 속성이 되며 해당 클래스로 만든 모든 인스턴스가 값을 공유한다. 클래스 속성은 `self` 또는 클래스 뒤에 `.`(점)을 붙여서 접근한다.

```python
class 클래스이름:
    속성 = 값               # 클래스 속성 만들기

    def 메서드(self):
        self.속성           # self 뒤에 .을 붙여서 클래스 속성에 접근
        클래스.속성         # 클래스 뒤에 .을 붙여서 클래스 속성에 접근

클래스.속성                 # 클래스 속성에 접근
```

속성을 만들 때 `__속성`과 같이 `__`(밑줄 두 개)로 시작하면 비공개 속성이 된다. 비공개 속성은 클래스 안에서만 접근할 수 있고, 클래스 바깥에서는 접근할 수 없다(비공개 메서드도 같은 방식).

```python
class 클래스이름:
    __속성 = 값             # 비공개 클래스 속성

    def __init__(self):
        self.__속성 = 값    # 비공개 인스턴스 속성
```



정적 메서드와 클래스 메서드
===========================

정적 메서드와 클래스 메서드는 인스턴스를 통하지 않고 클래스에서 바로 호출할 수 있는 메서드이다. 정적 메서드는 메서드 위에 `@staticmethod`를 붙이며 매개변수에 `self`를 지정하지 않는다.

```python
class 클래스이름:
    @staticmethod       # 정적 메서드 만들기
    def 메서드(매개변수1, 매개변수2):
        코드
```

정적 메서드는 `self`를 받지 않으므로 인스턴스 속성에 접근할 수 없다. 따라서 정적 메서드는 인스턴스 속성, 인스턴스 메서드가 필요 없을 때 사용한다.

클래스 메서드는 메서드 위에 `@classmethod`를 붙이며 매개변수에 `cls`를 지정한다.

```python
class 클래스이름:
    @classmethod    # 클래스 메서드 만들기
    def 메서드(cls, 매개변수1, 매개변수2):
        코드
```

클래스 메서드는 메서드 안에서 클래스 속성, 클래스 메서드에 접근해야 할 때 사용한다.



클래스 상속
===========

클래스 상속은 물려받은 기능을 유지한 채로 다른 기능을 추가할 때 사용한다. 기능을 물려주는 클래스를 기반 클래스, 상속을 받아 새롭게 만드는 클래스를 파생 클래스라고 한다.

상속은 클래스를 만들 때 `()`(괄호)를 붙이고 괄호 안에 기반 클래스 이름을 넣어준다.

```python
class 기반클래스이름:
    코드

class 파생클래스이름(기반클래스이름):       # 기반 클래스를 상속받음
    코드
```

기반 클래스의 속성에 접근하거나 메서드를 호출할 때는 `super()` 뒤에 `.`을 붙여서 사용한다. 또는, `super(파생클래스, self) ` 형식으로 사용할 수도 있다.

```python
class 기반클래스이름:
    def __init__(self):
        self.속성 = 값

class 파생클래스이름(기반클래스이름):
    def __init__(self):
        super().__init__()              # super()로 기반 클래스의 메서드 호출
        super().속성                    # super()로 기반 클래스의 속성에 접근
        super(파생클래스, self).속성    # super에 파생 클래스와 self를 넣는 형식
```



상속 관계와 포함 관계
=====================

상속은 학생과 사람처럼 명확하게 같은 종류이며 동등한 관계일 때 사용하며 `is-a` 관계라고 부른다. 포함은 사람과 사람 목록처럼 동등한 관계가 아닐 포함 관계일 때 사용하며 `has-a` 관계라고 부른다.



메서드 오버라이딩
=================

파생 클래스에서 기반 클래스의 메서드를 새로 정의하는 것을 메서드 오버라이딩이라고 한다. 메서드 오버라이딩은 파생 클래스에서 메서드를 정의할 때 기반 클래스의 메서드 이름과 똑같이 만들어준다.

```python
class Person:
    def greeting(self):
        pass

class Student(Person):
    def greeting(self):         # 메서드 오버라이딩
        super().greeting()      # super()로 기반 클래스의 메서드 호출

james = Student()
james.greeting()                # Student의 greeting 메서드가 호출 됨
```

메서드 오버라이딩은 원래 기능을 유지하면서 새로운 기능을 덧붙일 때, 프로그램에서 어떤 기능이 같은 메서드 이름으로 계속 사용되어야 할 때 활용한다.



다중 상속
=========

다중 상속은 여러 기반 클래스로부터 상속을 받아서 파생 클래스를 만드는 방법이다. 클래스를 만들 때 `()`(괄호) 안에 클래스 이름을, `,`(콤마)로 구분해서 넣어준다.

```python
class 기반클래스이름1:
    코드

class 기반클래스이름2:
    코드

class 파생클래스이름(기반클래스이름1, 기반클래스이름2):     # 다중 상속 사용하기
    코드
```



추상 클래스
===========

추상 클래스는 메서드 목록만 가진 클래스이며 상속받는 클래스에서 메서드 구현을 강제하기 위해 사용한다. 추상 클래스를 사용하려면 `import`로 `abc` 모듈을 가져온 뒤 클래스의 `()`(괄호) 안에 `metaclass=ABCMeta`를 지정하고, 메서드 위에 `@abstractmethod`를 붙여준다.

```python
from abc import *

class 추상클래스이름(metaclass=ABCMeta):    # 추상 클래스 만들기
    @abstractmethod
    def 메서드이름(self):
        코드
```