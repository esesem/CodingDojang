# UNIT 1 소프트웨어 교육과 파이썬

<br>

처리하고자 하는 작업 또는 문제는 다른 말로 요구사항이라고도 부른다. 즉, 프로그램을 작성하는 직업은 요구사항을 만족시키는 일이 된다. 컴퓨터는 물리적인 기계로 구성되어 있어서 하드웨어라고 하는데 이에 대비되는 개념으로 프로그램은 소프웨어라고 한다. 그래서 컴퓨터 프로그래밍은 다른 말로 소프트웨어 개발이라고 한다.

<br>

프로그래밍과 코딩?
------------------

어떨 때는 프로그래밍이라고 했다가 어떨 때는 코딩이라고 하고 좀 헷갈린다. 사실 둘 다 같은 작업을 지칭한다. 프로그래밍은 컴퓨터 명령어로 표현한다는 뜻이라 컴퓨터 쪽에 가깝고, 코딩은 파이썬 등의 프로그래밍 언어로 코드를 작성한다는 뜻이라 언어 쪽에 가까운 표현이다.

<br><br>



# UNIT 3 IDLE에서 Hello, world! 출력해보기

<br>

대화형 셸
---------

파이썬 셸은 파이썬 인터프리터와 대화하듯이 코드를 처리한다고 해서 대화형 셸(interactive shell) 또는 인터렉티브 모드(interactive mode)라고도 부른다. 특히 이런 방식을 코드를 읽고, 평가(계산, 실행)하고, 출력한다고 해서 REPL(Read-Eval-Print Loop)이라고 한다.

<br><br>



# UNIT 5 숫자 계산하기

<br>

몫과 나머지를 함께 구하기
-------------------------

몫과 나머지를 함께 구하려면 `divmod`를 사용하면 된다.

```python
>>> divmod(5, 2)
(2, 1)
```

5를 2로 나누었을 때 몫은 2, 나머지는 1이며 결과는 `(2, 1)` 형태로 나온다. `(2, 1)`처럼 파이썬에서 값을 괄호로 묶은 형태를 튜플(tuple)이라고 하며 값 여러 개를 모아서 표현할 때 사용한다.

튜플은 변수 여러 개에 저장할 수 있는데 `divmod`의 결과가 튜플로 나오므로 몫과 나머지는 변수 두 개에 저장할 수 있다.

<br>

2진수, 8진수, 16진수
--------------------

정수는 10진수 이외에도 2진수, 8진수, 16진수로도 표현할 수 있다.

* 2진수: 숫자 앞에 `0b`를 붙이며 0과 1을 사용한다.
* 8진수: 숫자 앞에 `0o`(숫자 0과 소문자 o)를 붙이며 0부터 7까지 사용한다.
* 16진수: 숫자 앞에 `0x` 또는 `0X`를 붙이며 0부터 9, A부터 F까지 사용한다(소문자 a부터 f도 가능).

```python
>>> 0b110
6
>>> 0o10
8
>>> 0xF
15
```

<br>

복소수
------

파이썬에서는 실수부와 허수부로 이루어진 복소수(complex number)도 사용할 수 있다. 이때 허수부는 숫자 뒤에 `j`를 붙인다(수학에서는 허수를 i로 표현하지만 공학에서는 j를 사용한다.)

```python
>>> 1.2+1.3j
(1.2+1.3j)
```

두 실수를 복소수로 만들 때는 `complex`를 사용하면 된다.

```python
>>> complex(1.2, 1.3)
(1.2+1.3j)
```

<br><br>



# UNIT 6 변수와 입력 사용하기

<br>

변수 삭제하기
-------------

변수 삭제는 `del`을 사용한다.

```python
>>> x = 10
>>> del x
>>> x
Trackback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    x
NameError: name 'x' is not defined
```

변수 `x`를 삭제하여 변수가 없어졌으므로 `x`가 정의되지 않았다는 메시지와 함께 NameError가 발생한다.

<br>

빈 변수 만들기
--------------

변수를 만들 때 `x = 10`과 같이 할당할 값을 지정해주었다. 그럼 값이 들어있지 않은 변수는 만들 수 없을까? 값이 들어있지 않은 빈 변수를 만들 때는 `None`을 할당해주면 된다.

```python
>>> x = None
>>> print(x)
None
>>> x
>>> (아무것도 출력되지 않음)
```

<br><br>



# UNIT 8 불과 비교, 논리 연산자 알아보기

<br>

정수 객체와 실수 객체가 서로 다른 것은 어떻게 확인하나?
-------------------------------------------------------

정수 객체와 실수 객체가 서로 다른지 확인하려면 `id` 함수를 사용하면 된다. `id`는 객체의 고유한 값(메모리 주소)을 구한다(이 값은 파이썬을 실행하는 동안에는 계속 유지되며 다시 실행하면 달라진다).

```python
>>> id(1)
1714767504
>>> id(1.0)
55320032
```

두 객체의 고유한 값이 다르므로 서로 다른 객체이다. 그래서 1과 1.0을 `is`로 비교하면 `False`가 나온다. `is`, `is not`은 클래스로 객체를 만든 뒤에 객체가 서로 다른지 비교할 때 주로 사용한다.

여기에 나오는 객체의 고유한 값(메모리 주소)에 대해서는 신경 쓸 필요 없다. `==`, `!=`와 `is`, `is not`의 동작 방식이 다르다는 정도만 알아 두면 된다.

<br>

값 비교에 `is`를 쓰지 않기
--------------------------

값을 비교할 때는 `is`를 사용하면 안 된다. 다음과 같이 변수 `a`에 -5를 할당한 뒤 `a is -5`를 실행하면 `True`가 나오지만 다시 -6을 할당한 뒤 `a is -6`을 실행하면 `False`가 나온다.

```python
>>> a = -5
>>> a is -5
True
>>> a = -6
>>> a is -6
False
```

<br>

정수, 실수, 문자열을 불로 만들기
--------------------------------

정수, 실수, 문자열을 불로 만들 때는 `bool`을 사용하면 된다. 이 때 정수 1은 `True`, 0은 `False`이다. 만약 문자열의 내용이 `'False'`라도 불로 만들면 `True`이다. 문자열의 내용 자체는 판단하지 않으며 값이 있으면 `True`이다.

즉, 정수 0, 실수 0.0 이외의 모든 숫자는 `True`이다. 그리고 빈 문자열 `''`, `""`를 제외한 모든 문자열은 `True`이다.

```python
>>> bool(1)
True
>>> bool(0)
False
>>> bool(1.5)
True
>>> bool('False')
True
```

<br>

단락 평가
---------

논리 연산에서 중요한 부분이 **단락 평가(short-circuit evalution)**이다. 단락 평가는 첫 번째 값만으로 결과가 확실할 때 두 번째 값은 확인(평가)하지 않는 방법을 말한다. 즉, `and` 연산자는 두 값이 모두 참이라야 참이므로 첫 번째 값이 거짓이면 두 번째 값은 확인하지 않고 바로 거짓으로 결정한다.

```python
# 첫 번째 값이 거짓이므로 두 번째 값은 확인하지 않고 거짓으로 결정
print(False and True)           # False
print(False and False)          # False
```

`or` 연산자는 두 값 중 하나만 참이므로 첫 번째 값이 참이면 두 번째 값은 확인하지 않고 바로 참으로 결정한다.

```python
# 첫 번째 값이 참이므로 두 번째 값은 확인하지 않고 참으로 결정
print(True or True)             # True
print(True or False)            # True
```

특히 파이썬에서 논리 연산자는 이 단락 평가에 따라 반환하는 값이 결정된다. `True`, `False`를 논리 연산자로 확인하면 `True`, `False`가 나왔는데, `True and 'Python'`의 결과는 무엇이 나올까?

```python
>>> True and 'Python'
'Python'
```

문자열 `'Python'`도 bool로 따지면 `True`라서 `True and True`가 되어 `True`가 나올 것 같지만 `'Python'`이 나온다. 왜냐하면 파이썬에서 논리 연산자는 마지막으로 단락 평가를 실시한 값을 그대로 반환하기 때문이다. 따라서 논리 연산자는 무조건 bool을 반환하지 않는다.

다음과 같이 마지막으로 단락 평가를 실시한 값이 bool이면 bool을 반환하게 된다.

```python
>>> 'Python' and True
True
>>> 'Python' and False
False
```

<br><br>



# UNIT 10 리스트와 튜플 사용하기

<br>

리스트와 튜플로 변수 만들기
---------------------------

리스트와 튜플을 사용하면 변수 여러 개를 한 번에 만들 수 있다. 이 때 변수의 개수와 리스트(튜플)의 요소 개수는 같아야 한다.

```python
>>> a, b, c = [1, 2, 3]
>>> print(a, b, c)
1 2 3
>>> d, e, f = (4, 5, 6)
>>> print(d, e, f)
4 5 6
```

리스트와 튜플 변수로도 변수 여러 개를 만들 수 있다. 다음과 같이 리스트와 튜플의 요소를 변수 여러 개에 할당하는 것을 리스트 언패킹(list unpacking), 튜플 언패킹(tuple unpacking)이라고 한다.

```python
>>> x = [1, 2, 3]
>>> a, b, c = x
>>> print(a, b, c)
1 2 3
>>> y = (4, 5, 6)
>>> d, e, f = y
>>> print(d, e, f)
4, 5, 6
```

`input().split()`은 리스트를 반환한다. 그래서 리스트 언패킹 형식으로 입력 값을 변수 여러 개에 저장할 수 있다.

```python
>>> input().split()
10 20
['10', '20']
>>> x = input().split()
10 20
>>> a, b = x
>>> print(a, b)
10 20
```

그리고 리스트 패킹(list packing)과 튜플 패킹(tuple packing)은 변수에 리스트 또는 튜플을 할당하는 과정을 뜻한다.

```python
a = [1, 2, 3]       # 리스트 패킹
b = (1, 2, 3)       # 튜플 패킹
c = 1, 2, 3         # 튜플 패킹
```

<br><br>



# UNIT 11 시퀀스 자료형 활용하기

<br>

`__getitem__` 메서드
--------------------

시퀀스 객체에서 `[]`(대괄호)를 사용하면 실제로는 `__getitem__` 메서드를 호출하여 요소를 가져온다. 따라서 다음과 같이 `__getitem__` 메서드를 직접 호출하여 요소를 가져올 수도 있다.

* `시퀀스객체.__getitem__(인덱스)`

```python
>>> a = [38, 21, 53, 62, 19]
>>> a.__getitem__(1)
21
```

<br>

슬라이스의 인덱스 증가폭을 음수로 지정하면?
-------------------------------------------

슬라이스를 사용할 때 인덱스 증가폭을 음수로 지정하면 요소를 뒤에서부터 가져올 수 있다. 다음은 리스트 `a`에서 인덱스 5부터 2까지 1씩 감소시키면서 요소를 가져온다.

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[5:1:-1]
[50, 40, 30, 20]
```

여기서 주의할 점은 인덱스가 감소하므로 끝 인덱스보다 시작 인덱스를 더 크게 지정해야 한다는 점이다. 즉, `a[5:1:-1]`과 같이 시작 인덱스부터 끝 인덱스까지 감소하도록 지정한다. 그리고 끝 인덱스는 가져오려는 범위에 포함되지 않는다.

특히 다음과 같이 시작 인덱스와 끝 인덱스를 생략하면서 인덱스 증가폭을 -1로 지정하면 어떻게 될까? 이때는 리스트 전체에서 인덱스를 1씩 감소시키면서 요소를 가져오므로 리스트를 반대로 뒤집는다.

```python
>>> a[::-1]
[90, 80, 70, 60, 50, 40, 30, 20, 10, 0]
```

물론 이 방법은 리스트뿐만 아니라 모든 시퀀스 객체에 사용할 수 있다.

<br><br>



# UNIT 14 else를 사용하여 두 방향으로 분기하기

<br>

`True`, `False`로 취급하는 것들
-------------------------------

다음은 파이썬 문법 중에서 `False`로 취급하는 것들이다.

* `None`
* `False`
* 0인 숫자들: 0, 0.0, 0j
* 비어 있는 문자열, 리스트, 튜플, 딕셔너리, 세트: `''`, `""`, `[]`, `()`, `{}`, `set()`
* 클래스 인스턴스의 `__bool__()`, `__len__()` 메서드가 0 또는 `False`를 반환할 때

앞에서 나열한 것들을 제외한 모든 요소는 `True`로 취급한다.

<br><br>


# UNIT 16 for 반복문으로 Hello, world! 100번 출력하기

<br>

버전별 `range`의 차이점
-----------------------

파이썬 2.7과 파이썬 3에서 `range`는 결과가 조금 다르다. 파이썬 2.7에서는 `range`를 사용하면 실제로 연속된 숫자가 들어있는 리스트를 만들어내지만 파이썬 3에서는 `range` 객체(반복 가능한 객체)를 만들어낸다.

```python
# 파이썬 2.7
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

```python
# 파이썬 3
>>> range(10)
range(0, 10)
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

파이썬 2.7의 `range`는 리스트를 만들어내므로 아주 큰 숫자를 지정하면 메모리를 많이 사용하게 된다. 그래서 보통 파이썬 2.7에서 리스트 대신 객체를 생성할 때는 `xrange`를 사용한다. 특히 파이썬 3에서는 `range`가 객체를 생성하는 방식으로 바뀌었다.

<br><br>



# UNIT 17 while 반복문으로 Hello, world! 100번 출력하기

<br>

`random.choice`
---------------

`random.choice` 함수를 사용하면 시퀀스 객체에서 요소를 무작위로 선택할 수 있다. 다음은 1, 2, 3, 4, 5, 6이 들어있는 리스트에서 무작위로 숫자를 선택한다.

* `random.choice(시퀀스객체)`

```python
>>> dice = [1, 2, 3, 4, 5, 6]
>>> random.choice(dice)
1
>>> random.choice(dice)
4
>>> random.choice(dice)
3
```

물론 `random.choice` 함수는 시퀀스 객체를 받으므로 리스트뿐만 아니라 튜플, range, 문자열 등을 넣어도 된다.

<br><br>



# UNIT 22 리스트와 튜플 응용하기

<br>

리스트로 스택과 큐 만들기
-------------------------

지금까지 알아본 리스트의 메서드로 스택(stack)과 큐(queue)를 만들 수 있다. 다음과 같이 `append`와 `pop`을 호출하는 그림을 90도로 돌리면 스택의 모습이 된다.

![그림 22-7 리스트로 스택 만들기](https://dojang.io/pluginfile.php/13694/mod_page/content/6/022007.png)

여기서 `pop()` 대신 `pop(0)`을 사용하면 큐가 된다.

![그림 22-8 리스트로 큐 만들기](https://dojang.io/pluginfile.php/13694/mod_page/content/6/022008.png)

물론 `append()`, `pop(0)`이 아닌 `insert(0, 요소)`, `pop()`을 사용해서 추가/삭제 방향을 반대로 해도 큐가 된다.
파이썬에서 스택은 리스트를 그대로 활용해도 되지만, 큐는 좀 더 효율적으로 사용할 수 있도록 덱(deque, double ended queue)이라는 자료형을 제공한다. 덱은 양쪽 끝에서 추가/삭제가 가능한 자료 구조이다.

* `deque(반복가능한 객체)`

```python
>>> from collections import deque   # collections 모듈에서 deque를 가져옴
>>> a = deque([10, 20, 30])
>>> a
deque([10, 20, 30])
>>> a.append(500)                   # 덱의 오른쪽에 500 추가
>>> a
deque([10, 20, 30, 500])
>>> a.popleft()                     # 덱의 왼쪽 요소 하나 삭제
10
>>> a
deque([20, 30, 500])
```

`deque`의 `append`는 덱의 오른쪽에 요소를 추가하고, `popleft`는 덱의 왼쪽 요소를 삭제한다. 반대로 `appendleft`는 덱의 왼쪽에 요소를 추가하고, `pop`으로 덱의 오른쪽 요소를 삭제할 수도 있다. 

<br>

`sort` 메서드와 `sorted` 함수
-----------------------------

파이썬은 리스트의 `sort` 메서드뿐만 아니라 내장 함수 `sorted`도 제공한다. `sort`와 `sorted` 모두 정렬을 해주는 함수지만, 약간의 차이점이 있다. `sort`는 메서드를 사용한 리스트를 변경하지만, `sorted` 함수는 정렬된 새 리스트를 생성한다.

```python
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.sort()    # a의 내용을 변경하여 정렬
>>> a
[10, 15, 20, 20, 30, 40]
>>> b = [10, 20, 30, 15, 20, 40]
>>> sorted(b)   # 정렬된 새 리스트를 상성
[10, 15, 20, 20, 30, 40]
```

<br>

리스트가 비어 있는지 확인하기
-----------------------------

리스트(시퀀스 객체)가 비어 있는지 확인하려면 어떻게 해야 할까? 방법은 간단하다. 리스트는 `len` 함수로 길이를 구할 수 있다. 이걸 `if` 조건문으로 판단하면 리스트가 비어 있는지 확인할 수 있다.

```python
if not len(seq):    # 리스트가 비어 있으면 True
if len(seq):        # 리스트에 요소가 있으면 True
```

하지만 파이썬에서는 이 방법보다 리스트(시퀀스 객체)를 바로 `if` 조건문으로 판단하는 방법을 권장한다(PEP 8).

```python
if not seq:     # 리스트가 비어 있으면 True
if seq:         # 리스트에 내용이 있으면 True
```

특히 리스트가 비어 있는지 확인하는 방법은 리스트의 마지막 요소에 접근할 때 유용하게 사용할 수 있다. 리스트의 마지막 요소에 접근할 때는 인덱스를 -1로 지정하면 된다.

```python
>>> seq = [10, 20, 30]
>>> seq[-1]
30
```

만약 리스트가 비어 있을 경우에는 인덱스를 -1로 지정하면 에러가 발생한다.

```python
>>> a = []
>>> a[-1]
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    a[-1]
IndexError: list index out of range
```

이 때는 조건문을 활용하여 리스트에 요소가 있을 때만 마지막 요소를 가져오면 된다.

```python
seq = []
if seq:                 # 리스트에 요소가 있는지 확인
    print(seq[-1])      # 요소가 있을 때만 마지막 요소를 가져옴
```

<br>

`for` 반복문에서 인덱스로 요소를 출력하기
-----------------------------------------

`for`에 리스트를 지정하면 요소를 바로 가져와서 편리한데, `for`에서 인덱스를 지정하여 요소를 가져올 수는 없을까? 이때는 `range`에 `len`으로 리스트의 길이(요소 개수)를 구해서 넣어주면 인덱스를 순서대로 만들어준다. 따라서 `a[i]`와 같이 리스트에 인덱스를 지정하여 값을 가져올 수 있다.

```python
>>> a = [38, 21, 53, 62, 19]
>>> for i in range(len(a))
... print(a[i])
...
38
21
53
62
19
```

즉, `for in range(len(a))`를 실행하면 `i`에는 요소가 아닌 0부터 마지막 인덱스까지 인덱스가 들어간다.

<br>

대괄호와 `list()` 리스트 표현식
-------------------------------

리스트 표현식은 `[식 for 변수 in 리스트]`처럼 `[]`(대괄호)로 만들 수도 있고, `list(식 for 변수 in 리스트)`처럼 `list`로 만들 수도 있다. 둘 중에 성능은 대괄호 방식이 더 좋다. 특히 `list` 방식은 C 언어 스타일이라 대괄호 방식이 파이썬 다운 코드이다. 따라서 리스트 표현식은 대괄호 방식을 사용하는 것이 좋다. `list`는 리스트 표현식을 만들 수 있다는 정도만 알아 두면 된다.

<br><br>



# UNIT 23 2차원 리스트 사용하기

<br>

사람이 알아보기 쉽게 출력하기
-----------------------------

2차원 리스트를 출려갛면 한 줄로 쭉 붙어서 출력된다.

```python
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> a
[[10, 20], [30, 40], [50, 60]]
```

만약 2차원 리스트의 사각형 구조를 유지하도록 출력하려면 `pprint` 모듈의 `pprint` 함수를 사용한다.

```python
>>> from pprint import pprint
>>> pprint(a, indent=4, width=20)
[   [10, 20],
    [30, 40],
    [50, 60]]
```

`indent`는 들여쓰기 칸 수, `width`는 가로 폭이다. 각자 상황에 맞게 들여쓰기 칸 수와 가로 폭을 조절해서 사용한다.

<br>

`sorted`로 2차원 리스트 정렬하기
--------------------------------

2차원 리스트를 정렬할 때는 `sorted` 함수를 사용한다.

* `sorted(반복가능한객체, key=정렬함수, reverse=True 또는 False)`

다음은 학생 정보가 저장된 2차원 리스트를 정렬한다.

```python
students = [
    ['john', 'C', 19],
    ['maria', 'A', 25],
    ['andrew', 'B', 7]
]
print(sorted(students, key=lambda student: student[1]))     # 안쪽 리스트의 인덱스 1을 기준으로 정렬
print(sorted(students, key=lambda student: student[2]))     # 안쪽 리스트의 인덱스 2를 기준으로 정렬
```

```shell
[['maria', 'A', 25], ['andrew', 'B', 7], ['john', 'C', 19]]
[['andrew', 'B', 7], ['john', 'C', 19], ['maria', 'A', 25]]
```

`sorted`의 `key`에 정렬 함수를 지정하여 안쪽 리스트의 요소를 기준으로 정렬했다. `student[1]`은 안쪽 리스트의 인덱스 1을 뜻하며 `'A', 'B', 'C'` 순으로 정렬한다. 마찬가지로 `student[2]`는 안쪽 리스트의 인덱스 2를 뜻하며 `7, 19, 25` 순으로 정렬한다.

<br><br>



# UNIT 24 문자열 응용하기

<br>

구두점을 간단하게 삭제하기
--------------------------

`string` 모듈의 `punctuation`에는 모든 구두점이 들어있다. 다음과 같이 `strip` 메서드에 `string.punctuation`을 넣으면 문자열 양쪽의 모든 구두점을 간단하게 삭제할 수 있다.

```python
>>> import string
>>> ',python.'.strip(string.punctuation)
'python'
>>> string.punctuation
'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
```

만약 공백까지 삭제하고 싶다면 `string.punctuation`에 공백 `' '`을 연결해서 넣어주면 된다.

```python
>>> ', python.'.strip(string.punctuation + ' ')
'python'
```

물론 메서드 체이닝을 활용해도 된다.

```python
>>> ', python.'.strip(string.punctuation).strip()
'python'
```

<br>

금액에서 천단위로 콤마 넣기
---------------------------

숫자 중에서 금액은 천단위로 `,`(콤마)를 넣는다. 파이썬에서는 간단하게 천단위로 콤마를 넣을 수 있다.  
먼저 `format` 내장 함수를 사용하는 방법이다. 다음과 같이 `format` 함수에 숫자와 `','`를 넣어준다.

* `format(숫자, ',')`

```python
>>> format(1493500, ',')
'1,493,500'
```

`format` 함수는 서식 지정자와 함께 사용할 수 있다. 다음은 콤마를 넣은 숫자를 오른쪽 정렬한다.

```python
>>> '%20s' % format(1493500, ',')       # 길이 20, 오른쪽으로 정렬
'           1,493,500'
```

포매팅에서 콤마를 넣으려면 다음과 같이 `:`(콜론)뒤에 `,`(콤마)를 지정하면 된다.

```python
>>> '{0:,}'.format(1493500)
'1,493,500'
```

만약 정렬을 하고 싶다면 정렬 방향과 길이 뒤에 콤마를 지정해준다.

```python
>>> '{0:>20,}'.format(1493500)      # 길이 20, 오른쪽으로 정렬
'           1,493,500'
>>> '{0:0>20,}'.format(1493500)     # 길이 20, 오른쪽으로 정렬하고 남는 공간은 0으로 채움
'000000000001,493,500'
```

<br><br>



# UNIT 25 딕셔너리 응용하기

<br>

`sefdefault`와 `update`의 차이
------------------------------

`setdefault`는 키-값 쌍 추가만 할 수 있고, 이미 들어있는 키의 값은 수정할 수 없다. 하지만 `update`는 키-값 쌍 추가와 값 수정이 모두 가능하다. 다음과 같이 `setdefault`로 이미 들어있는 키 `'a'`를 90으로 저장해도 `'a'`의 값은 바뀌지 않는다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.setdefault('a', 90)
10
>>> x
{'a': 10, 'b': 20, 'c': 30, 'd': 40}
```

<br>

defaultdict 사용하기
----------------------

지금까지 사용한 딕셔너리(dict)는 없는 키에 접근했을 경우 에러가 발생한다.

```python
>>> x = {'a': 0, 'b': 0, 'c': 0, 'd': 0}
>>> x['z']      # 키 'z'는 없음
Traceback (most recent call last):
  File "<pyshell#4>", line 1, in <module>
    x['z']
KeyError: 'z'
```

그러면 에러가 발생하지 않게 하려면 어떻게 해야 할까? 이때는 defaultdict를 사용한다.  
defaultdict는 없는 키에 접근하더라도 에러가 발생하지 않으며 기본값을 반환한다. defaultdict는 collections 모듈에 들어있으며 기본값 생성 함수를 넣는다.

* `defaultdict(기본값생성함수)`

다음은 기본값이 0인 defaultdict 딕셔너리를 만든다.

```python
>>> from collections import defaultdict     # collections 모듈에서 defaultdict를 가져옴
>>> y = defaultdict(int)                    # int로 기본값 생성
```

딕셔너리 `y`에는 키 `'z'`가 없지만 `y['z']`와 같이 키의 값을 가져와 보면 0이 나온다. 왜나하면 기본값을 0으로 설정했기 때문이다.

```python
>>> y['z']
0
```

`defaultdict(int)`처럼 `int`를 넣었는데 기본값이 왜 0인지 의문이 생길 수도 있다. `int`는 실수나 문자열을 정수로 변환하지만, 다음과 같이 `int`에 아무것도 넣지 않고 호출하면 0을 반환한다.

```python
>>> int()
0
```

defaultdict에는 특정 값을 반환하는 함수를 넣어주면 되는데, `defaultdict(int)`는 기본값 생성 함수로 int를 지정하여 0이 나오도록 만든 것이다.  
0이 아닌 다른 값을 기본값으로 설정하고 싶다면 다음과 같이 기본값 생성 함수를 만들어서 넣어주면 된다.

```python
>>> z = defaultdict(lambda: 'python')
>>> z['a']
'python'
>>> z[0]
'python'
```

여기서는 문자열 `'python'`을 반환하는 `lambda: 'python'`을 넣어서 `'python'`이 기본값이 되도록 설정했다.

<br><br>



# UNIT 26 세트 사용하기

<br>

세트 안에 세트 넣기
-------------------

세트는 리스트, 딕셔너리와 달리 세트 안에 세트를 넣을 수 없다.

```python
>>> a = {{1, 2}, {3, 4}}
Traceback (most recent call last):
  File "<pyshell#14>", line 1, in <module>
    a = {{1, 2}, {3, 4}}
TypeError: unhashable type: 'set'
```

<br>

프로즌 세트
-----------

파이썬은 내용을 변경할 수 없는 세트도 제공한다.

* `프로즌세트 = frozenset(반복가능한각체)`

```python
>>> a = frozenset(range(10))
>>> a
frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})
```

이름 그대로 얼어 있는(frozen) 세트이다. frozenset는 집합 연산과 메서드에서 요소를 추가하거나 삭제하는 연산, 메서드는 사용할 수 없다. 즉, 다음과 같이 frozenset의 요소를 변경하려고 하면 에러가 발생한다.

```python
>>> a = frozenset(range(10))
>>> a |= 10
Traceback (most recent call last):
  File "<pyshell#18>", line 1, in <module>
    a |= 10
TypeError: unsupported operand type(s) for |=: 'frozenset' and 'int'
>>> a.update({10})
Traceback (most recent call last):
  File "<pyshell#19>", line 1, in <module>
    a.update({10})
AttributeError: 'frozenset' object has no attribute 'update'
```

그런데 요소를 변경할 수 없는 frozenset는 왜 사용할까? frozenset는 세트 안에 세트를 넣고 싶을 때 사용한다. 다음과 같이 frozenset는 frozenset를 중첩해서 넣을 수 있다. 단, frozenset만 넣을 수 있고, 일반 set는 넣을 수 없다.

```python
>>> frozenset({frozenset({1, 2}), frozenset({3, 4})})
frozenset({frozenset({3, 4}), frozenset({1, 2})})
```

<br><br>



# UNIT 27 파일 사용하기

<br>

파일 객체는 이터레이터
----------------------

파일 객체는 이터레이터이다. 따라서 변수 여러 개에 저장하는 언패킹(unpacking)도 가능하다.

```python
>>> file = open('hello.txt', 'r')
>>> a, b, c = file
>>> a, b, c
('안녕하세요.\n', '파이썬\n', '코딩 도장입니다.\n')
```

<br>

다른 파일 모드는 없나?
----------------------

사실 파일 모드는 조합에 따라 여러 종류가 있다. 읽기 `'r'`, 쓰기 `'w'` 이외에 추가 `'a'`, 배타적 생성 `'x'`도 있다. 추가 모드는 이미 있는 파일에서 끝에 새로운 내용을 추가할 때 사용하고, 배타적 생성 모드는 파일이 이미 있으면 에러(FileExistsError)를 발생시키고 없으면 파일을 만든다. `'x'`는 배타적 생성(exclusive creation)의 x이다.  
또한, 파일의 형식도 함께 지정할 수 있는데 텍스트 모드 `'t'`와 바이너리 모드 `'b'`가 있다. 이 파일 형식과 읽기, 쓰기 모드를 조합한 텍스트 모드 `'rt'`, `'wt'`는 파일을 텍스트 모드로 연다. 특히 텍스트 모드는 생략할 수 있어서 그냥 `'r'`, `'w'`도 텍스트 모드이다. 그리고 바이너리 모드 `'rb'`, `'wb'` 등은 피클링을 사용하거나 바이너리 데이터를 직접 저장할 때 사용한다.  
그 다음에 `'+'`가 있는데 파일을 읽기/쓰기 모드로 연다. 이 모드는 `'r+t'`, `'w+t'`, `'r+'`, `'w+'`, `'r+b'`, `'w+b'` 등으로 조합할 수 있으며 읽기/쓰기 모드인 것은 같지만 파일 처리 방법이 조금씩 다르다.  
지금까지 나온 파일 모드 조합을 그림으로 정리하면 다음과 같은 구조가 된다.

![그림 27-4 파일 모드 조합](https://dojang.io/pluginfile.php/13766/mod_page/content/3/027004.png)

<br><br>








순수 함수와 비순수 함수
-----------------------

순수 함수(pure function)는 함수의 실행이 외부 상태에 영향을 끼치지 않는 함수를 뜻한다. 따라서 순수 함수는 부수 효과(side effect)가 없어야 하고 입력 값이 같으면 언제나 같은 출력 값을 반환한다.

```python
def add(a, b):          # 함수 실행이 외부 상태에 영향을 끼치지 않음
    return a + b

print(add(1, 2))
```

반대로 비순수 함수(impure function)는 수정자 함수(modifier function)라고도 하는데 함수의 실행이 외부 상태에 영향을 끼치는 함수이다.

```python
number_list = [1, 2, 3]

def append_number(n):           # 함수 실행이 외부 상태에 영향을 끼침
    number_list.append(n)       # 함수 외부에 있는 number_list의 상태가 바뀜

append_number(4)
```



First-Class Object
==================

일급 객체(first-class object)란 다음 조건을 만족하는 객체를 뜻한다.

* 변수나 데이터 구조에 넣을 수 있어야 한다.
* 매개변수에 전달할 수 있어야 한다.
* 반환값으로 사용할 수 있어야 한다.

특히 일급 함수(first-class function)는 일급 객체의 조건을 만족하면서 실행 중(run-time)에 함수를 생성할 수 있어야 한다. 파이썬에서는 `def` 안에서 `def`로 함수를 만들거나, `lambda`를 사용하여 실행 중에 함수를 생성할 수 있으므로 파이썬의 함수는 일급 함수이다.


다른 언어에 있는 `switch` 문법은 사용할 수 없나?
------------------------------------------------

파이썬은 `switch` 문법이 없다. 하지만 딕셔너리와 람다 표현식을 사용하면 `switch`처럼 사용할 수는 있다.

```python
switch = {
    '+': lambda x, y: x + y,
    '*': lambda x, y: x * y
}

x = '+'

try:
    print(switch[x](10, 20))
except KeyError:
    print('default')
```